"use strict";(globalThis.webpackChunkphysical_ai_robotics_book=globalThis.webpackChunkphysical_ai_robotics_book||[]).push([[3750],{8420:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>s,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"module-05-humanoid-control/part-01-locomotion/bipedal-locomotion","title":"Bipedal Locomotion","description":"This chapter delves into the mechanics and control strategies for bipedal walking in humanoid robots. Bipedal locomotion is one of the most challenging aspects of humanoid robotics, requiring precise balance control, dynamic stability, and coordinated movement of multiple body segments. The chapter covers both theoretical foundations and practical implementation approaches.","source":"@site/docs/module-05-humanoid-control/part-01-locomotion/02-bipedal-locomotion.md","sourceDirName":"module-05-humanoid-control/part-01-locomotion","slug":"/module-05-humanoid-control/part-01-locomotion/bipedal-locomotion","permalink":"/Physical_AI_And_Humanoid_Robotics_Book/docs/module-05-humanoid-control/part-01-locomotion/bipedal-locomotion","draft":false,"unlisted":false,"editUrl":"https://github.com/Tayyaba-Akbar956/Physical_AI_And_Humanoid_Robotics_Book/tree/main/docs/module-05-humanoid-control/part-01-locomotion/02-bipedal-locomotion.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"Bipedal Locomotion"},"sidebar":"tutorialSidebar","previous":{"title":"Humanoid Kinematics","permalink":"/Physical_AI_And_Humanoid_Robotics_Book/docs/module-05-humanoid-control/part-01-locomotion/humanoid-kinematics"},"next":{"title":"Humanoid Robotics Overview","permalink":"/Physical_AI_And_Humanoid_Robotics_Book/docs/module-05-humanoid-control/part-01-locomotion/humanoid-overview"}}');var i=t(4848),r=t(8453);const s={sidebar_position:2,title:"Bipedal Locomotion"},a="Bipedal Locomotion",l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction: The Challenge of Two-Legged Walking",id:"introduction-the-challenge-of-two-legged-walking",level:2},{value:"Key Challenges in Robotic Bipedal Locomotion",id:"key-challenges-in-robotic-bipedal-locomotion",level:3},{value:"Core Concepts",id:"core-concepts",level:2},{value:"Walking Phases",id:"walking-phases",level:3},{value:"Dynamic Balance Models",id:"dynamic-balance-models",level:3},{value:"Gait Parameters",id:"gait-parameters",level:3},{value:"Mathematical Framework",id:"mathematical-framework",level:2},{value:"Inverted Pendulum Dynamics",id:"inverted-pendulum-dynamics",level:3},{value:"Zero-Moment Point (ZMP)",id:"zero-moment-point-zmp",level:3},{value:"Linear Inverted Pendulum Model (LIPM)",id:"linear-inverted-pendulum-model-lipm",level:3},{value:"Practical Implementation",id:"practical-implementation",level:2},{value:"ZMP-Based Walking Pattern Generation",id:"zmp-based-walking-pattern-generation",level:3},{value:"Foot Trajectory Generation",id:"foot-trajectory-generation",level:3},{value:"Balance Control Implementation",id:"balance-control-implementation",level:3},{value:"Walking Control Strategies",id:"walking-control-strategies",level:2},{value:"Model Predictive Control (MPC)",id:"model-predictive-control-mpc",level:3},{value:"Preview Control",id:"preview-control",level:3},{value:"Advanced Walking Techniques",id:"advanced-walking-techniques",level:2},{value:"Walking on Uneven Terrain",id:"walking-on-uneven-terrain",level:3},{value:"Turning and Direction Changes",id:"turning-and-direction-changes",level:3},{value:"Troubleshooting Common Issues",id:"troubleshooting-common-issues",level:2},{value:"Instability During Walking",id:"instability-during-walking",level:3},{value:"Foot Slipping",id:"foot-slipping",level:3},{value:"Excessive Energy Consumption",id:"excessive-energy-consumption",level:3},{value:"Asymmetric Walking",id:"asymmetric-walking",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Design Considerations",id:"design-considerations",level:3},{value:"Control Implementation",id:"control-implementation",level:3},{value:"Testing and Validation",id:"testing-and-validation",level:3},{value:"Hands-on Exercise",id:"hands-on-exercise",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2},{value:"Further Reading",id:"further-reading",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"bipedal-locomotion",children:"Bipedal Locomotion"})}),"\n",(0,i.jsx)(n.p,{children:"This chapter delves into the mechanics and control strategies for bipedal walking in humanoid robots. Bipedal locomotion is one of the most challenging aspects of humanoid robotics, requiring precise balance control, dynamic stability, and coordinated movement of multiple body segments. The chapter covers both theoretical foundations and practical implementation approaches."}),"\n",(0,i.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Understand the dynamics of bipedal walking"}),"\n",(0,i.jsx)(n.li,{children:"Implement control strategies for stable bipedal locomotion"}),"\n",(0,i.jsx)(n.li,{children:"Analyze the differences between human and robotic walking"}),"\n",(0,i.jsx)(n.li,{children:"Apply dynamic balance concepts to walking control"}),"\n",(0,i.jsx)(n.li,{children:"Design walking patterns for humanoid robots"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"introduction-the-challenge-of-two-legged-walking",children:"Introduction: The Challenge of Two-Legged Walking"}),"\n",(0,i.jsx)(n.p,{children:"Bipedal locomotion is one of the most complex motor tasks humans perform effortlessly, but it presents significant challenges for robots. Unlike wheeled vehicles that can maintain stability through continuous contact with the ground, bipedal robots must constantly adjust their posture to maintain balance while moving. This requires sophisticated control algorithms and precise actuator coordination."}),"\n",(0,i.jsx)(n.p,{children:"Human walking involves several phases:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Double Support"}),": Both feet are in contact with the ground"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Single Support"}),": Only one foot is in contact with the ground"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Swing Phase"}),": One foot is moving forward while the other supports the body"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Transfer Phase"}),": Weight is transferred from one foot to the other"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"During walking, the human body constantly makes micro-adjustments to maintain balance, using sensory feedback from the vestibular system, visual input, and proprioceptive sensors."}),"\n",(0,i.jsx)(n.h3,{id:"key-challenges-in-robotic-bipedal-locomotion",children:"Key Challenges in Robotic Bipedal Locomotion"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Dynamic Balance"}),": Maintaining stability during the single-support phase"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Ground Impact"}),": Managing the forces generated when the foot contacts the ground"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Energy Efficiency"}),": Minimizing energy consumption while walking"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Terrain Adaptation"}),": Adjusting to uneven surfaces and obstacles"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Robustness"}),": Maintaining walking even with perturbations and disturbances"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,i.jsx)(n.h3,{id:"walking-phases",children:"Walking Phases"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Double Support Phase"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Both feet are in contact with the ground"}),"\n",(0,i.jsx)(n.li,{children:"The center of mass transitions from one foot to the other"}),"\n",(0,i.jsx)(n.li,{children:"Provides stability during weight transfer"}),"\n",(0,i.jsx)(n.li,{children:"Generally shorter in faster walking"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Single Support Phase"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Only one foot is in contact with the ground"}),"\n",(0,i.jsx)(n.li,{children:"The body's center of mass follows an inverted pendulum motion"}),"\n",(0,i.jsx)(n.li,{children:"Requires active balance control"}),"\n",(0,i.jsx)(n.li,{children:"Forms the majority of the walking cycle"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"dynamic-balance-models",children:"Dynamic Balance Models"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Inverted Pendulum Model"}),":\nThe simplest model for bipedal walking treats the robot as an inverted pendulum pivoting over the stance foot. This model captures the essential dynamics of balance control:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Center of mass moves in an arc above the support foot"}),"\n",(0,i.jsx)(n.li,{children:"Stability depends on controlling the CoM position relative to the support point"}),"\n",(0,i.jsx)(n.li,{children:"Can be linearized around the upright position"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Linear Inverted Pendulum (LIP)"}),":\nA more practical model that assumes the center of mass height remains constant:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"CoM moves at a constant height above the ground"}),"\n",(0,i.jsx)(n.li,{children:"Simplifies the mathematics while retaining essential dynamics"}),"\n",(0,i.jsx)(n.li,{children:"Allows for analytical solutions to balance control"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Capture Point"}),":\nA key concept in bipedal balance - the point on the ground where the robot can step to stop its current momentum:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"If the CoM velocity vector passes through the capture point, the robot can stop"}),"\n",(0,i.jsx)(n.li,{children:"Determines where the robot should place its foot for stability"}),"\n",(0,i.jsx)(n.li,{children:"Critical for recovery from disturbances"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"gait-parameters",children:"Gait Parameters"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Step Length"}),": Distance between the heel of the stance foot and the heel of the swing foot at initial contact."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Step Width"}),": Lateral distance between the feet during walking."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Step Height"}),": Maximum height of the swing foot above the ground during the swing phase."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Stride Length"}),": Distance traveled by the body between two consecutive heel contacts of the same foot."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Walking Speed"}),": Average forward velocity of the robot."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Step Frequency"}),": Number of steps per unit time."]}),"\n",(0,i.jsx)(n.h2,{id:"mathematical-framework",children:"Mathematical Framework"}),"\n",(0,i.jsx)(n.h3,{id:"inverted-pendulum-dynamics",children:"Inverted Pendulum Dynamics"}),"\n",(0,i.jsx)(n.p,{children:"The dynamics of the inverted pendulum model can be described by:"}),"\n",(0,i.jsx)(n.p,{children:"L * d\xb2\u03b8/dt\xb2 = g * sin(\u03b8)"}),"\n",(0,i.jsx)(n.p,{children:"Where:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"L is the pendulum length (CoM height)"}),"\n",(0,i.jsx)(n.li,{children:"\u03b8 is the angle from vertical"}),"\n",(0,i.jsx)(n.li,{children:"g is the acceleration due to gravity"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"For small angles, this linearizes to:\nL * d\xb2\u03b8/dt\xb2 = g * \u03b8"}),"\n",(0,i.jsx)(n.h3,{id:"zero-moment-point-zmp",children:"Zero-Moment Point (ZMP)"}),"\n",(0,i.jsx)(n.p,{children:"The ZMP is a critical concept in bipedal locomotion:"}),"\n",(0,i.jsx)(n.p,{children:"ZMP_x = CoM_x - (h/g) * CoM_acc_x\nZMP_y = CoM_y - (h/g) * CoM_acc_y"}),"\n",(0,i.jsx)(n.p,{children:"Where:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"CoM_x, CoM_y are the center of mass coordinates"}),"\n",(0,i.jsx)(n.li,{children:"h is the CoM height above the ground"}),"\n",(0,i.jsx)(n.li,{children:"CoM_acc_x, CoM_acc_y are the CoM acceleration components"}),"\n",(0,i.jsx)(n.li,{children:"g is the acceleration due to gravity"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"For stable walking, the ZMP must remain within the support polygon defined by the feet."}),"\n",(0,i.jsx)(n.h3,{id:"linear-inverted-pendulum-model-lipm",children:"Linear Inverted Pendulum Model (LIPM)"}),"\n",(0,i.jsx)(n.p,{children:"In the LIPM, the center of mass height remains constant:"}),"\n",(0,i.jsx)(n.p,{children:"CoM(t) = ZMP + (CoM(0) - ZMP) * cosh(t/\u03c4) + CoM_dot(0) * \u03c4 * sinh(t/\u03c4)"}),"\n",(0,i.jsx)(n.p,{children:"Where:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u03c4 = \u221a(h/g) is the time constant of the pendulum"}),"\n",(0,i.jsx)(n.li,{children:"CoM(0) and CoM_dot(0) are the initial position and velocity"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"practical-implementation",children:"Practical Implementation"}),"\n",(0,i.jsx)(n.h3,{id:"zmp-based-walking-pattern-generation",children:"ZMP-Based Walking Pattern Generation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import numpy as np\nfrom scipy import integrate\n\nclass ZMPBasedWalker:\n    def __init__(self, robot_params):\n        \"\"\"\n        Initialize ZMP-based walking controller\n        \n        Args:\n            robot_params: Dictionary containing robot physical parameters\n        \"\"\"\n        self.robot_height = robot_params.get('robot_height', 0.8)  # height of CoM\n        self.step_length = robot_params.get('step_length', 0.3)   # desired step length\n        self.step_width = robot_params.get('step_width', 0.2)    # lateral foot distance\n        self.walk_period = robot_params.get('walk_period', 1.0)  # time for one step\n        self.gravity = 9.81\n        self.tau = np.sqrt(self.robot_height / self.gravity)  # time constant\n        \n        # Initialize walking state\n        self.current_support_foot = 'right'  # Start with right foot support\n        self.step_count = 0\n        self.current_pos = [0.0, 0.0, 0.0]  # x, y, z position\n        \n    def generate_zmp_trajectory(self, step_time, start_pos, target_pos):\n        \"\"\"\n        Generate ZMP trajectory for a single step\n        \n        Args:\n            step_time: Time duration of the step\n            start_pos: Starting CoM position\n            target_pos: Target CoM position after step\n        \n        Returns:\n            Array of ZMP positions over time\n        \"\"\"\n        # Simplified ZMP trajectory generation\n        # In practice, this would use more sophisticated methods like spline interpolation\n        # or numerical optimization\n        \n        # Create time vector\n        dt = 0.01  # 10ms time steps\n        time_vec = np.arange(0, step_time, dt)\n        \n        # For a simple walk, ZMP moves from one foot to the other\n        # This is a simplified model where ZMP moves linearly between foot positions\n        if self.current_support_foot == 'right':\n            # Right foot support, ZMP starts at right foot position\n            zmp_start = [start_pos[0], start_pos[1] - self.step_width/2]\n            zmp_end = [target_pos[0], target_pos[1] + self.step_width/2]  # Next left foot\n        else:\n            # Left foot support, ZMP starts at left foot position\n            zmp_start = [start_pos[0], start_pos[1] + self.step_width/2]\n            zmp_end = [target_pos[0], target_pos[1] - self.step_width/2]  # Next right foot\n        \n        # Linear interpolation for ZMP trajectory\n        zmp_traj = []\n        for t in time_vec:\n            ratio = t / step_time\n            zmp_x = zmp_start[0] + ratio * (zmp_end[0] - zmp_start[0])\n            zmp_y = zmp_start[1] + ratio * (zmp_end[1] - zmp_start[1])\n            zmp_traj.append([zmp_x, zmp_y])\n        \n        return np.array(zmp_traj), time_vec\n    \n    def calculate_com_trajectory(self, zmp_trajectory, time_vector):\n        \"\"\"\n        Calculate CoM trajectory from ZMP trajectory using LIPM\n        \n        Args:\n            zmp_trajectory: Array of ZMP positions over time\n            time_vector: Time values corresponding to ZMP positions\n        \n        Returns:\n            CoM trajectory over time\n        \"\"\"\n        # Solve the LIPM equation: CoM(t) = ZMP(t) + (CoM(0) - ZMP(0)) * cosh(t/\u03c4) + CoM_dot(0) * \u03c4 * sinh(t/\u03c4)\n        # This is a simplified implementation\n        \n        com_trajectory = []\n        \n        # Initial conditions (would be determined from robot state)\n        initial_com = np.array([0.0, 0.0])  # Initial CoM position (x, y)\n        initial_com_vel = np.array([0.0, 0.0])  # Initial CoM velocity\n        \n        # For the first point\n        com_trajectory.append(initial_com.copy())\n        \n        # Calculate CoM at each time step based on ZMP\n        for i in range(1, len(time_vector)):\n            dt = time_vector[i] - time_vector[i-1]\n            \n            # In a full implementation, this would solve the LIPM differential equation\n            # Here's a simplified approach using discrete integration\n            \n            # This is still a simplified version - a complete implementation would\n            # solve the differential equation of the LIPM model\n            current_zmp = zmp_trajectory[i]\n            prev_com = com_trajectory[i-1]\n            \n            # Approximate using the LIPM relationship\n            # CoM acceleration = g/h * (CoM - ZMP)\n            if i == 1:  # Use initial conditions\n                prev_com = initial_com\n                com_vel = initial_com_vel\n            else:\n                com_vel = (com_trajectory[i-1] - com_trajectory[i-2]) / dt if i > 1 else initial_com_vel\n            \n            # Calculate acceleration based on CoM-ZMP difference\n            com_acc = (self.gravity / self.robot_height) * (prev_com - current_zmp)\n            \n            # Update CoM position using kinematic equations\n            new_com = prev_com + com_vel * dt + 0.5 * com_acc * dt**2\n            com_trajectory.append(new_com)\n            \n        return np.array(com_trajectory)\n    \n    def generate_foot_steps(self, walk_distance, step_count):\n        \"\"\"\n        Generate a sequence of foot positions for walking\n        \n        Args:\n            walk_distance: Total distance to walk\n            step_count: Number of steps to take\n        \n        Returns:\n            List of foot positions (x, y, z) for each step\n        \"\"\"\n        foot_steps = []\n        \n        # Start position\n        current_x = 0\n        current_y = 0\n        \n        for i in range(step_count):\n            # Determine which foot to place\n            if i % 2 == 0:  # Even steps: place left foot (if starting with right support)\n                foot_x = current_x + self.step_length\n                foot_y = current_y + self.step_width / 2\n                foot_type = 'left'\n            else:  # Odd steps: place right foot\n                foot_x = current_x + self.step_length\n                foot_y = current_y - self.step_width / 2\n                foot_type = 'right'\n            \n            # Update current position for next step\n            current_x = foot_x\n            current_y = 0  # Reset to center line\n            \n            foot_steps.append({\n                'step_number': i + 1,\n                'type': foot_type,\n                'position': [foot_x, foot_y, 0],\n                'time': (i + 1) * self.walk_period\n            })\n        \n        return foot_steps\n    \n    def walk_cycle(self, step_number, next_support_pos):\n        \"\"\"\n        Execute a single walking step\n        \n        Args:\n            step_number: The current step number\n            next_support_pos: Position of the next support foot\n        \n        Returns:\n            Trajectory for the step\n        \"\"\"\n        # Generate ZMP trajectory for this step\n        zmp_trajectory, time_vector = self.generate_zmp_trajectory(\n            self.walk_period, \n            self.current_pos[:2], \n            next_support_pos[:2]\n        )\n        \n        # Calculate CoM trajectory from ZMP\n        com_trajectory = self.calculate_com_trajectory(zmp_trajectory, time_vector)\n        \n        # Switch support foot\n        self.current_support_foot = 'left' if self.current_support_foot == 'right' else 'right'\n        \n        # Update current position based on last CoM position\n        self.current_pos[0] = com_trajectory[-1][0]\n        self.current_pos[1] = com_trajectory[-1][1]\n        \n        return {\n            'step_number': step_number,\n            'zmp_trajectory': zmp_trajectory,\n            'com_trajectory': com_trajectory,\n            'time_vector': time_vector,\n            'current_pos': self.current_pos.copy()\n        }\n\n# Example usage\nif __name__ == \"__main__\":\n    # Robot parameters\n    robot_params = {\n        'robot_height': 0.8,      # Height of CoM in meters\n        'step_length': 0.3,       # Step length in meters\n        'step_width': 0.2,        # Step width in meters\n        'walk_period': 1.0        # Time per step in seconds\n    }\n    \n    # Initialize walker\n    walker = ZMPBasedWalker(robot_params)\n    \n    # Generate walking pattern for 5 steps\n    steps = walker.generate_foot_steps(walk_distance=1.5, step_count=5)\n    \n    print(\"Foot steps planned:\")\n    for step in steps:\n        print(f\"Step {step['step_number']} ({step['type']}): {step['position']} at t={step['time']:.2f}s\")\n    \n    # Execute first step\n    next_support_pos = steps[0]['position']  # Position for next support foot\n    step_result = walker.walk_cycle(1, next_support_pos)\n    \n    print(f\"\\nStep 1 trajectory calculated with {len(step_result['time_vector'])} time steps\")\n    print(f\"Final CoM position: {step_result['com_trajectory'][-1]}\")\n"})}),"\n",(0,i.jsx)(n.h3,{id:"foot-trajectory-generation",children:"Foot Trajectory Generation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class FootTrajectoryGenerator:\n    def __init__(self, robot_params):\n        """\n        Generate trajectories for foot movement during walking\n        \n        Args:\n            robot_params: Dictionary containing robot parameters\n        """\n        self.step_height = robot_params.get(\'step_height\', 0.05)  # foot clearance in meters\n        self.swing_duration_ratio = robot_params.get(\'swing_ratio\', 0.35)  # portion of step for swing\n        self.foot_length = robot_params.get(\'foot_length\', 0.25)    # length of foot in meters\n        \n    def generate_foot_trajectory(self, lift_pos, land_pos, step_duration):\n        """\n        Generate a trajectory for the foot from lift to landing position\n        \n        Args:\n            lift_pos: Position where foot lifts off (x, y, z)\n            land_pos: Position where foot lands (x, y, z)\n            step_duration: Total duration of the step\n        \n        Returns:\n            Array of foot positions over time\n        """\n        dt = 0.01  # 10ms time steps\n        time_steps = int(step_duration / dt)\n        time_vector = np.linspace(0, step_duration, time_steps)\n        \n        trajectory = []\n        \n        # Calculate swing phase duration and double support phase duration\n        swing_duration = step_duration * self.swing_duration_ratio\n        double_support_duration = step_duration * (1 - self.swing_duration_ratio) / 2\n        \n        for i, t in enumerate(time_vector):\n            # Determine which phase of step we\'re in\n            if t <= double_support_duration:\n                # Initial double support phase - foot remains at old position\n                pos = lift_pos.copy()\n            elif t >= step_duration - double_support_duration:\n                # Final double support phase - foot remains at new position\n                pos = land_pos.copy()\n            else:\n                # Swing phase\n                # Calculate normalized time within swing phase\n                swing_t = (t - double_support_duration) / swing_duration\n                \n                # Calculate x and y positions (linear interpolation)\n                x = lift_pos[0] + swing_t * (land_pos[0] - lift_pos[0])\n                y = lift_pos[1] + swing_t * (land_pos[1] - lift_pos[1])\n                \n                # Calculate z position (parabolic trajectory for foot clearance)\n                # Peak at middle of swing phase\n                z = lift_pos[2] + 4 * self.step_height * swing_t * (1 - swing_t)\n                \n                pos = [x, y, z]\n            \n            trajectory.append(pos)\n        \n        return np.array(trajectory), time_vector\n\n# Example usage of foot trajectory\nif __name__ == "__main__":\n    # Initialize foot trajectory generator\n    params = {\'step_height\': 0.05, \'swing_ratio\': 0.35, \'foot_length\': 0.25}\n    foot_gen = FootTrajectoryGenerator(params)\n    \n    # Generate trajectory for a step\n    lift_pos = [0.0, -0.1, 0.0]  # Starting foot position\n    land_pos = [0.3, 0.1, 0.0]   # Landing foot position\n    step_dur = 1.0               # Step duration in seconds\n    \n    foot_traj, time_vec = foot_gen.generate_foot_trajectory(lift_pos, land_pos, step_dur)\n    \n    print(f"Generated foot trajectory with {len(foot_traj)} points")\n    print(f"Foot lifts at: {foot_traj[0]}")\n    print(f"Foot lands at: {foot_traj[-1]}")\n    print(f"Max foot height: {np.max(foot_traj[:, 2]):.3f}m")\n'})}),"\n",(0,i.jsx)(n.h3,{id:"balance-control-implementation",children:"Balance Control Implementation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class BalanceController:\n    def __init__(self, robot_params):\n        """\n        Advanced balance controller for humanoid robots\n        \n        Args:\n            robot_params: Dictionary containing robot parameters\n        """\n        self.mass = robot_params.get(\'total_mass\', 50.0)\n        self.com_height = robot_params.get(\'robot_height\', 0.8)\n        self.gravity = 9.81\n        self.tau = np.sqrt(self.com_height / self.gravity)\n        \n        # PID controller parameters for balance\n        self.kp_com = robot_params.get(\'kp_com\', 40.0)    # Proportional gain for CoM\n        self.kd_com = robot_params.get(\'kd_com\', 20.0)    # Derivative gain for CoM\n        self.kp_foot = robot_params.get(\'kp_foot\', 10.0)  # Proportional gain for foot placement\n        self.control_dt = 0.01  # 10ms control loop\n        \n        # State estimation\n        self.current_com = np.array([0.0, 0.0, self.com_height])\n        self.current_com_vel = np.array([0.0, 0.0, 0.0])\n        self.current_zmp = np.array([0.0, 0.0, 0.0])\n    \n    def update_state(self, measured_com, measured_com_vel):\n        """Update controller with current state measurements"""\n        self.current_com = measured_com\n        self.current_com_vel = measured_com_vel\n        \n        # Estimate ZMP from current CoM state\n        # ZMP = CoM - (h/g) * CoM_acc\n        # Since we don\'t have acceleration directly, we estimate it or use it from state\n        # This is a simplified approach - in practice, ZMP would be measured with force sensors\n        self.current_zmp = self.estimate_zmp()\n    \n    def estimate_zmp(self):\n        """Estimate Zero Moment Point from current CoM state"""\n        # This is a simplified estimation\n        # In practice, ZMP is typically measured using force/torque sensors in the feet\n        return np.array([self.current_com[0], self.current_com[1], 0.0])\n    \n    def compute_balance_control(self, desired_zmp):\n        """\n        Compute balance control corrections\n        \n        Args:\n            desired_zmp: Target ZMP position for stability\n        \n        Returns:\n            Joint adjustments needed for balance\n        """\n        # Calculate ZMP error\n        zmp_error = desired_zmp[:2] - self.current_zmp[:2]\n        \n        # Calculate CoM error\n        com_error = desired_zmp[:2] - self.current_com[:2]\n        \n        # PID control for CoM position\n        com_control = self.kp_com * com_error  # + self.kd_com * com_velocity_error\n        \n        # Calculate corrective forces needed\n        corrective_force = self.mass * self.gravity * com_control / self.com_height\n        \n        # Convert to joint angle adjustments (conceptual mapping)\n        # In reality, this mapping would be more complex and specific to the robot\n        joint_corrections = {\n            \'hip_roll\': corrective_force[1] * 0.1,  # Lateral force -> hip roll\n            \'hip_pitch\': corrective_force[0] * 0.1, # Forward force -> hip pitch\n            \'ankle_roll\': corrective_force[1] * 0.2, # Lateral force -> ankle roll\n            \'ankle_pitch\': corrective_force[0] * 0.2 # Forward force -> ankle pitch\n        }\n        \n        return joint_corrections\n    \n    def calculate_capture_point(self, com_pos, com_vel):\n        """\n        Calculate the capture point for balance recovery\n        \n        Args:\n            com_pos: Current center of mass position\n            com_vel: Current center of mass velocity\n        \n        Returns:\n            Capture point position where robot should step to stop\n        """\n        # Capture point = CoM position + CoM velocity * sqrt(h/g)\n        capture_point = com_pos[:2] + com_vel[:2] * self.tau\n        return capture_point\n    \n    def adjust_step_location(self, current_support_pos, com_pos, com_vel):\n        """\n        Adjust planned step location based on balance requirements\n        \n        Args:\n            current_support_pos: Current support foot position\n            com_pos: Current CoM position\n            com_vel: Current CoM velocity\n        \n        Returns:\n            Adjusted step location for next foot\n        """\n        # Calculate where we need to step to maintain balance\n        capture_point = self.calculate_capture_point(com_pos, com_vel)\n        \n        # The foot should be placed near the capture point for stability\n        # But we also need to consider the natural walking pattern\n        desired_step = capture_point\n        \n        # Check if this step location is reasonable (within leg reach)\n        step_distance = np.linalg.norm(desired_step - current_support_pos[:2])\n        max_reach = 0.4  # Maximum comfortable step distance\n        \n        if step_distance > max_reach:\n            # Scale the step to maximum comfortable reach\n            direction = (desired_step - current_support_pos[:2]) / step_distance\n            desired_step = current_support_pos[:2] + direction * max_reach\n        \n        return desired_step\n'})}),"\n",(0,i.jsx)(n.h2,{id:"walking-control-strategies",children:"Walking Control Strategies"}),"\n",(0,i.jsx)(n.h3,{id:"model-predictive-control-mpc",children:"Model Predictive Control (MPC)"}),"\n",(0,i.jsx)(n.p,{children:"MPC for walking involves solving an optimization problem at each time step to determine the best future actions:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class WalkingMPC:\n    def __init__(self, prediction_horizon=10):\n        self.horizon = prediction_horizon\n        self.weights = {\n            'zmp_tracking': 10.0,    # Importance of tracking ZMP references\n            'com_velocity': 1.0,     # Penalty for CoM velocity\n            'step_size': 0.5,        # Penalty for large step sizes\n            'control_effort': 0.1    # Penalty for control effort\n        }\n    \n    def solve_optimization(self, current_state, reference_trajectory):\n        \"\"\"\n        Solve the MPC optimization problem\n        (In practice, this would use a numerical optimization solver)\n        \"\"\"\n        # This is a conceptual implementation\n        # A real implementation would use quadratic programming or similar\n        pass\n"})}),"\n",(0,i.jsx)(n.h3,{id:"preview-control",children:"Preview Control"}),"\n",(0,i.jsx)(n.p,{children:"Preview control uses knowledge of future terrain or walking pattern to anticipate balance adjustments:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class PreviewController:\n    def __init__(self, preview_steps=10):\n        self.preview_steps = preview_steps\n        \n    def generate_preview_control(self, future_zmp_ref):\n        """\n        Generate control inputs based on preview of future ZMP references\n        """\n        # Uses the preview information to calculate appropriate CoM trajectory\n        # that will achieve future ZMP goals\n        pass\n'})}),"\n",(0,i.jsx)(n.h2,{id:"advanced-walking-techniques",children:"Advanced Walking Techniques"}),"\n",(0,i.jsx)(n.h3,{id:"walking-on-uneven-terrain",children:"Walking on Uneven Terrain"}),"\n",(0,i.jsx)(n.p,{children:"Adapting walking patterns for uneven surfaces requires:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Terrain height estimation"}),"\n",(0,i.jsx)(n.li,{children:"Adjusting foot placement"}),"\n",(0,i.jsx)(n.li,{children:"Modifying leg trajectories"}),"\n",(0,i.jsx)(n.li,{children:"Adapting step timing"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"turning-and-direction-changes",children:"Turning and Direction Changes"}),"\n",(0,i.jsx)(n.p,{children:"Implementing turning involves:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Coordinated step placement"}),"\n",(0,i.jsx)(n.li,{children:"Hip and torso rotation"}),"\n",(0,i.jsx)(n.li,{children:"Balance during direction changes"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"troubleshooting-common-issues",children:"Troubleshooting Common Issues"}),"\n",(0,i.jsx)(n.h3,{id:"instability-during-walking",children:"Instability During Walking"}),"\n",(0,i.jsx)(n.p,{children:"If your robot experiences walking instability:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Check ZMP tracking accuracy"}),"\n",(0,i.jsx)(n.li,{children:"Verify center of mass estimation"}),"\n",(0,i.jsx)(n.li,{children:"Adjust control gains appropriately"}),"\n",(0,i.jsx)(n.li,{children:"Ensure sensors are properly calibrated"}),"\n",(0,i.jsx)(n.li,{children:"Consider adding more conservative control parameters"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"foot-slipping",children:"Foot Slipping"}),"\n",(0,i.jsx)(n.p,{children:"To address foot slipping:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Reduce step velocity"}),"\n",(0,i.jsx)(n.li,{children:"Increase foot-ground friction modeling"}),"\n",(0,i.jsx)(n.li,{children:"Add force control to maintain contact"}),"\n",(0,i.jsx)(n.li,{children:"Use larger support polygons"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"excessive-energy-consumption",children:"Excessive Energy Consumption"}),"\n",(0,i.jsx)(n.p,{children:"For high energy usage:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Optimize step parameters for efficiency"}),"\n",(0,i.jsx)(n.li,{children:"Implement more natural walking gaits"}),"\n",(0,i.jsx)(n.li,{children:"Check for unnecessary joint movements"}),"\n",(0,i.jsx)(n.li,{children:"Consider using passive dynamics where possible"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"asymmetric-walking",children:"Asymmetric Walking"}),"\n",(0,i.jsx)(n.p,{children:"If the robot walks asymmetrically:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Verify sensor calibration"}),"\n",(0,i.jsx)(n.li,{children:"Check for mechanical asymmetries"}),"\n",(0,i.jsx)(n.li,{children:"Verify identical control parameters for both legs"}),"\n",(0,i.jsx)(n.li,{children:"Check for consistent actuator performance"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsx)(n.h3,{id:"design-considerations",children:"Design Considerations"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Design for robustness to model uncertainties"}),"\n",(0,i.jsx)(n.li,{children:"Include safety margins in balance calculations"}),"\n",(0,i.jsx)(n.li,{children:"Plan for sensor/actuator failures"}),"\n",(0,i.jsx)(n.li,{children:"Consider the trade-off between speed and stability"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"control-implementation",children:"Control Implementation"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Use sensor fusion for accurate state estimation"}),"\n",(0,i.jsx)(n.li,{children:"Implement hierarchical control (balance, locomotion, manipulation)"}),"\n",(0,i.jsx)(n.li,{children:"Include proper state machines for smooth transitions"}),"\n",(0,i.jsx)(n.li,{children:"Design controllers based on robot's physical capabilities"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"testing-and-validation",children:"Testing and Validation"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Test in simulation before real robot deployment"}),"\n",(0,i.jsx)(n.li,{children:"Start with small steps and conservative parameters"}),"\n",(0,i.jsx)(n.li,{children:"Gradually increase walking speed and complexity"}),"\n",(0,i.jsx)(n.li,{children:"Test on various terrains and conditions"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"hands-on-exercise",children:"Hands-on Exercise"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"ZMP Analysis"}),": Calculate and plot the ZMP trajectory for a simple walking pattern. Verify that it remains within the support polygon throughout the walk."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Inverted Pendulum Simulation"}),": Implement a simulation of the inverted pendulum model for bipedal walking. Observe how the CoM moves and the effect of different control parameters."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Capture Point Calculation"}),": Implement and test the capture point calculation for different CoM positions and velocities. Understand how this value determines recovery steps."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Step Parameter Tuning"}),": Experiment with different step lengths, widths, and heights to determine their effect on walking stability and efficiency."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Balance Recovery"}),": Create a simulation where the robot is pushed during walking and must recover balance by adjusting its next step location."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Bipedal walking requires precise balance control and coordinated movements"}),"\n",(0,i.jsx)(n.li,{children:"ZMP and Capture Point are fundamental concepts for walking stability"}),"\n",(0,i.jsx)(n.li,{children:"Walking patterns must be dynamically stable throughout the gait cycle"}),"\n",(0,i.jsx)(n.li,{children:"Control strategies must account for robot dynamics and environmental conditions"}),"\n",(0,i.jsx)(n.li,{children:"Simulation and careful testing are crucial for successful implementation"}),"\n",(0,i.jsx)(n.li,{children:"Energy efficiency is an important consideration in practical systems"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:'"Bipedal Locomotion: A Tutorial" - Kajita and Morisawa'}),"\n",(0,i.jsx)(n.li,{children:'"Humanoid Robotics" - Herr and Bellman'}),"\n",(0,i.jsx)(n.li,{children:'"Dynamics and Control of Bipedal Walking" - Technical papers'}),"\n",(0,i.jsx)(n.li,{children:'"Introduction to Humanoid Robotics" - Shumskaya and Kajita'}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsx)(n.p,{children:"Continue to Chapter 3: Balance Control to explore advanced techniques for maintaining stability during dynamic movements."})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>a});var o=t(6540);const i={},r=o.createContext(i);function s(e){const n=o.useContext(r);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);