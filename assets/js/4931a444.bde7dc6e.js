"use strict";(globalThis.webpackChunkphysical_ai_robotics_book=globalThis.webpackChunkphysical_ai_robotics_book||[]).push([[6165],{3217:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module-05-humanoid-control/part-02-interaction/manipulation","title":"Balance Control","description":"This chapter focuses on the critical aspect of balance control in humanoid robots. Maintaining balance is fundamental to humanoid locomotion and manipulation, requiring sophisticated control strategies to handle the inherently unstable nature of two-legged systems. The chapter covers both theoretical foundations and practical implementation approaches for maintaining stability in static and dynamic situations.","source":"@site/docs/module-05-humanoid-control/part-02-interaction/01-manipulation.md","sourceDirName":"module-05-humanoid-control/part-02-interaction","slug":"/module-05-humanoid-control/part-02-interaction/manipulation","permalink":"/docs/module-05-humanoid-control/part-02-interaction/manipulation","draft":false,"unlisted":false,"editUrl":"https://github.com/Tayyaba-Akbar956/Physical_AI_And_Humanoid_Robotics_Book/tree/main/docs/module-05-humanoid-control/part-02-interaction/01-manipulation.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"Balance Control"},"sidebar":"tutorialSidebar","previous":{"title":"Humanoid Robotics Overview","permalink":"/docs/module-05-humanoid-control/part-01-locomotion/humanoid-overview"},"next":{"title":"Human-Robot Interaction Design","permalink":"/docs/module-05-humanoid-control/part-02-interaction/hri-design"}}');var r=o(4848),i=o(8453);const a={sidebar_position:3,title:"Balance Control"},s="Balance Control",l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction: The Physics of Balance",id:"introduction-the-physics-of-balance",level:2},{value:"Key Balance Concepts",id:"key-balance-concepts",level:3},{value:"Balance Control Challenges",id:"balance-control-challenges",level:3},{value:"Core Concepts",id:"core-concepts",level:2},{value:"Stability Criteria",id:"stability-criteria",level:3},{value:"Balance Control Approaches",id:"balance-control-approaches",level:3},{value:"Feedback Control Strategies",id:"feedback-control-strategies",level:3},{value:"Mathematical Framework",id:"mathematical-framework",level:2},{value:"Center of Mass Dynamics",id:"center-of-mass-dynamics",level:3},{value:"Zero-Moment Point (ZMP) Equation",id:"zero-moment-point-zmp-equation",level:3},{value:"Linear Inverted Pendulum Model (LIPM)",id:"linear-inverted-pendulum-model-lipm",level:3},{value:"Practical Implementation",id:"practical-implementation",level:2},{value:"Sensor-Based Balance Control",id:"sensor-based-balance-control",level:3},{value:"Advanced Balance Control: LQR-Based Approach",id:"advanced-balance-control-lqr-based-approach",level:3},{value:"Capture Point-Based Balance Recovery",id:"capture-point-based-balance-recovery",level:3},{value:"Model Predictive Control (MPC) for Balance",id:"model-predictive-control-mpc-for-balance",level:3},{value:"Advanced Balance Strategies",id:"advanced-balance-strategies",level:2},{value:"Whole-Body Balance Control",id:"whole-body-balance-control",level:3},{value:"Disturbance Handling",id:"disturbance-handling",level:3},{value:"Troubleshooting Common Issues",id:"troubleshooting-common-issues",level:2},{value:"Oscillations and Instability",id:"oscillations-and-instability",level:3},{value:"Excessive Joint Torques",id:"excessive-joint-torques",level:3},{value:"Drifting Behavior",id:"drifting-behavior",level:3},{value:"Slow Response to Perturbations",id:"slow-response-to-perturbations",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Robust Control Design",id:"robust-control-design",level:3},{value:"Sensor Integration",id:"sensor-integration",level:3},{value:"Safety Considerations",id:"safety-considerations",level:3},{value:"Validation and Testing",id:"validation-and-testing",level:3},{value:"Hands-on Exercise",id:"hands-on-exercise",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2},{value:"Further Reading",id:"further-reading",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"balance-control",children:"Balance Control"})}),"\n",(0,r.jsx)(n.p,{children:"This chapter focuses on the critical aspect of balance control in humanoid robots. Maintaining balance is fundamental to humanoid locomotion and manipulation, requiring sophisticated control strategies to handle the inherently unstable nature of two-legged systems. The chapter covers both theoretical foundations and practical implementation approaches for maintaining stability in static and dynamic situations."}),"\n",(0,r.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Understand the principles of dynamic balance in humanoid robots"}),"\n",(0,r.jsx)(n.li,{children:"Implement feedback control strategies for balance maintenance"}),"\n",(0,r.jsx)(n.li,{children:"Analyze the effects of perturbations on humanoid stability"}),"\n",(0,r.jsx)(n.li,{children:"Design control systems that handle both internal and external disturbances"}),"\n",(0,r.jsx)(n.li,{children:"Evaluate balance control performance through simulation and testing"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"introduction-the-physics-of-balance",children:"Introduction: The Physics of Balance"}),"\n",(0,r.jsx)(n.p,{children:"Balance in humanoid robots is fundamentally about maintaining the center of mass (CoM) within the support polygon defined by the points of contact with the ground. For a standing humanoid, this support polygon is typically the area covered by both feet. For a walking humanoid, the support polygon changes as feet transition between contact and swing phases."}),"\n",(0,r.jsx)(n.p,{children:"Humanoid robots are inherently unstable systems, similar to an inverted pendulum. Without active control, they would fall due to gravity. The challenge lies in developing control strategies that continuously adjust the robot's posture to maintain or restore balance, especially during dynamic activities like walking, running, or manipulation tasks."}),"\n",(0,r.jsx)(n.h3,{id:"key-balance-concepts",children:"Key Balance Concepts"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Support Polygon"}),": The convex hull of all ground contact points (feet, hands if touching ground)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Center of Mass"}),": The weighted average position of all mass in the robot"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Zero-Moment Point (ZMP)"}),": The point where the net moment of ground reaction forces equals zero"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Capture Point"}),": The point where the robot can step to stop its current momentum"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Stability Margin"}),": The distance between the ZMP and the boundary of the support polygon"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"balance-control-challenges",children:"Balance Control Challenges"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Dynamic Stability"}),": Maintaining balance during movement requires predictive control"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Multi-Task Coordination"}),": Balance must be maintained while performing other tasks"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sensor Noise"}),": Control systems must handle noisy sensor inputs robustly"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Model Uncertainties"}),": Real robots differ from models, requiring adaptive control"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Disturbance Rejection"}),": Systems must handle unexpected external forces"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,r.jsx)(n.h3,{id:"stability-criteria",children:"Stability Criteria"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Static Stability"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The center of mass projection must be within the support polygon"}),"\n",(0,r.jsx)(n.li,{children:"A positive stability margin provides additional safety"}),"\n",(0,r.jsx)(n.li,{children:"Static stability is necessary but not sufficient for dynamic movements"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Dynamic Stability"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Requires considering the robot's momentum and planned movements"}),"\n",(0,r.jsx)(n.li,{children:"The Zero-Moment Point (ZMP) must remain within the support polygon"}),"\n",(0,r.jsx)(n.li,{children:"Dynamic balance allows for temporary violations of static balance"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"balance-control-approaches",children:"Balance Control Approaches"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Model-Based Control"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Uses mathematical models of robot dynamics"}),"\n",(0,r.jsx)(n.li,{children:"Provides predictable behavior based on physical principles"}),"\n",(0,r.jsx)(n.li,{children:"Requires accurate models and parameters"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Sensor-Based Control"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Relies on real-time feedback from sensors (IMU, force/torque, encoders)"}),"\n",(0,r.jsx)(n.li,{children:"Robust to model uncertainties"}),"\n",(0,r.jsx)(n.li,{children:"Requires careful sensor fusion and filtering"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Learning-Based Control"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Uses machine learning to adapt control strategies"}),"\n",(0,r.jsx)(n.li,{children:"Can improve performance through experience"}),"\n",(0,r.jsx)(n.li,{children:"Requires training data and may lack theoretical guarantees"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"feedback-control-strategies",children:"Feedback Control Strategies"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Proportional-Integral-Derivative (PID) Control"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Basic control approach for maintaining desired balance states"}),"\n",(0,r.jsx)(n.li,{children:"Well-understood and widely used"}),"\n",(0,r.jsx)(n.li,{children:"May need tuning for complex humanoid dynamics"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Linear Quadratic Regulator (LQR)"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Optimal control approach for linearized systems around balance points"}),"\n",(0,r.jsx)(n.li,{children:"Provides mathematically optimal control for quadratic cost functions"}),"\n",(0,r.jsx)(n.li,{children:"Works well for small deviations from equilibrium"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Model Predictive Control (MPC)"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Advanced control that optimizes future actions based on a model"}),"\n",(0,r.jsx)(n.li,{children:"Can handle constraints and multi-objective optimization"}),"\n",(0,r.jsx)(n.li,{children:"Computationally intensive but very effective"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"mathematical-framework",children:"Mathematical Framework"}),"\n",(0,r.jsx)(n.h3,{id:"center-of-mass-dynamics",children:"Center of Mass Dynamics"}),"\n",(0,r.jsx)(n.p,{children:"The center of mass motion is governed by:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"m * d\xb2CoM/dt\xb2 = \u03a3 F_external\n"})}),"\n",(0,r.jsx)(n.p,{children:"Where:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"m is the total mass of the robot"}),"\n",(0,r.jsx)(n.li,{children:"CoM is the center of mass position vector"}),"\n",(0,r.jsx)(n.li,{children:"\u03a3 F_external represents all external forces (gravity, ground reaction, etc.)"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"For balance, the CoM must be controlled so that gravity and ground reaction forces maintain stability."}),"\n",(0,r.jsx)(n.h3,{id:"zero-moment-point-zmp-equation",children:"Zero-Moment Point (ZMP) Equation"}),"\n",(0,r.jsx)(n.p,{children:"The ZMP is computed as:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"ZMP_x = CoM_x - (h/g) * CoM_acc_x\nZMP_y = CoM_y - (h/g) * CoM_acc_y\n"})}),"\n",(0,r.jsx)(n.p,{children:"Where:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"(CoM_x, CoM_y) are the horizontal CoM coordinates"}),"\n",(0,r.jsx)(n.li,{children:"h is the CoM height above ground"}),"\n",(0,r.jsx)(n.li,{children:"(CoM_acc_x, CoM_acc_y) are the horizontal CoM accelerations"}),"\n",(0,r.jsx)(n.li,{children:"g is gravitational acceleration"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"For stability, ZMP must be within the support polygon."}),"\n",(0,r.jsx)(n.h3,{id:"linear-inverted-pendulum-model-lipm",children:"Linear Inverted Pendulum Model (LIPM)"}),"\n",(0,r.jsx)(n.p,{children:"In the LIPM, CoM height remains constant:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"CoM(t) = ZMP + (CoM(0) - ZMP) * cosh(t/\u03c4) + CoM_dot(0) * \u03c4 * sinh(t/\u03c4)\n"})}),"\n",(0,r.jsx)(n.p,{children:"Where \u03c4 = \u221a(h/g) is the pendulum time constant."}),"\n",(0,r.jsx)(n.h2,{id:"practical-implementation",children:"Practical Implementation"}),"\n",(0,r.jsx)(n.h3,{id:"sensor-based-balance-control",children:"Sensor-Based Balance Control"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'import numpy as np\nfrom scipy.spatial.transform import Rotation as R\n\nclass SensorBasedBalanceController:\n    def __init__(self, robot_params):\n        """\n        Initialize sensor-based balance controller\n        \n        Args:\n            robot_params: Dictionary containing robot parameters\n        """\n        self.mass = robot_params.get(\'total_mass\', 50.0)  # kg\n        self.com_height = robot_params.get(\'com_height\', 0.8)  # m\n        self.gravity = 9.81  # m/s\xb2\n        self.control_period = robot_params.get(\'control_period\', 0.01)  # s (100Hz)\n        \n        # PID gains for different control aspects\n        self.kp_roll = robot_params.get(\'kp_roll\', 100.0)    # Roll balance\n        self.kp_pitch = robot_params.get(\'kp_pitch\', 100.0)  # Pitch balance\n        self.kd_roll = robot_params.get(\'kd_roll\', 10.0)     # Roll damping\n        self.kd_pitch = robot_params.get(\'kd_pitch\', 10.0)   # Pitch damping\n        \n        # State variables\n        self.current_roll = 0.0\n        self.current_pitch = 0.0\n        self.roll_velocity = 0.0\n        self.pitch_velocity = 0.0\n        self.previous_roll_error = 0.0\n        self.previous_pitch_error = 0.0\n        \n        # Support polygon (simplified as a rectangle)\n        self.support_polygon_x = [-0.1, 0.1]  # meters\n        self.support_polygon_y = [-0.05, 0.05]  # meters (single foot)\n        \n        # Safety limits\n        self.max_torque = robot_params.get(\'max_torque\', 50.0)  # Nm\n    \n    def update_sensor_data(self, imu_data, force_data):\n        """\n        Update controller with sensor measurements\n        Args:\n            imu_data: [roll_angle, pitch_angle, roll_rate, pitch_rate] \n            force_data: [fx, fy, fz, mx, my, mz] (wrench at foot)\n        """\n        self.current_roll = imu_data[0]\n        self.current_pitch = imu_data[1]\n        self.roll_velocity = imu_data[2]\n        self.pitch_velocity = imu_data[3]\n        \n        # Could incorporate force data for advanced control\n        self.force_data = force_data\n    \n    def compute_balance_torques(self, desired_roll=0.0, desired_pitch=0.0):\n        """\n        Compute required torques to maintain balance\n        \n        Args:\n            desired_roll: Desired roll angle (default 0 for upright)\n            desired_pitch: Desired pitch angle (default 0 for upright)\n        \n        Returns:\n            Required torques [roll_torque, pitch_torque] in Nm\n        """\n        # Calculate errors\n        roll_error = desired_roll - self.current_roll\n        pitch_error = desired_pitch - self.current_pitch\n        \n        # PID control for roll\n        roll_proportional = self.kp_roll * roll_error\n        roll_derivative = self.kd_roll * (roll_error - self.previous_roll_error) / self.control_period\n        roll_torque = roll_proportional + roll_derivative\n        \n        # PID control for pitch\n        pitch_proportional = self.kp_pitch * pitch_error\n        pitch_derivative = self.kd_pitch * (pitch_error - self.previous_pitch_error) / self.control_period\n        pitch_torque = pitch_proportional + pitch_derivative\n        \n        # Apply safety limits\n        roll_torque = np.clip(roll_torque, -self.max_torque, self.max_torque)\n        pitch_torque = np.clip(pitch_torque, -self.max_torque, self.max_torque)\n        \n        # Update previous errors for derivative term\n        self.previous_roll_error = roll_error\n        self.previous_pitch_error = pitch_error\n        \n        return [roll_torque, pitch_torque]\n    \n    def estimate_com_position(self, joint_angles, link_lengths):\n        """\n        Estimate center of mass position from joint configuration\n        (Simplified implementation)\n        """\n        # This is a simplified CoM estimation\n        # In practice, this would use forward kinematics and mass distribution\n        # of each link\n        \n        # For now, return a placeholder based on joint angles\n        # A complete implementation would compute CoM based on the full kinematic chain\n        com_x = 0  # Calculated based on forward kinematics\n        com_y = 0  # Calculated based on forward kinematics\n        com_z = self.com_height  # Approximate height\n        \n        return np.array([com_x, com_y, com_z])\n    \n    def calculate_zmp(self, com_pos, com_acc):\n        """\n        Calculate Zero-Moment Point from CoM information\n        \n        Args:\n            com_pos: Center of mass position [x, y, z]\n            com_acc: Center of mass acceleration [x, y, z]\n        \n        Returns:\n            ZMP position [x, y, z]\n        """\n        zmp_x = com_pos[0] - (self.com_height / self.gravity) * com_acc[0]\n        zmp_y = com_pos[1] - (self.com_height / self.gravity) * com_acc[1]\n        \n        return np.array([zmp_x, zmp_y, 0.0])\n    \n    def is_balanced(self, zmp_pos):\n        """\n        Check if the robot is balanced based on ZMP position\n        \n        Args:\n            zmp_pos: Zero-Moment Point position [x, y, z]\n        \n        Returns:\n            Boolean indicating if balanced\n        """\n        x_ok = self.support_polygon_x[0] <= zmp_pos[0] <= self.support_polygon_x[1]\n        y_ok = self.support_polygon_y[0] <= zmp_pos[1] <= self.support_polygon_y[1]\n        \n        return x_ok and y_ok\n\n# Example usage\nif __name__ == "__main__":\n    # Robot parameters\n    robot_params = {\n        \'total_mass\': 50.0,\n        \'com_height\': 0.8,\n        \'control_period\': 0.01,\n        \'kp_roll\': 80.0,\n        \'kp_pitch\': 80.0,\n        \'kd_roll\': 8.0,\n        \'kd_pitch\': 8.0,\n        \'max_torque\': 50.0\n    }\n    \n    # Initialize balance controller\n    controller = SensorBasedBalanceController(robot_params)\n    \n    # Simulate sensor data (in reality, this would come from actual sensors)\n    imu_data = [0.01, -0.02, 0.1, -0.05]  # [roll, pitch, roll_rate, pitch_rate]\n    force_data = [10, -5, 490, 2, -1, 0]  # [fx, fy, fz, mx, my, mz]\n    \n    controller.update_sensor_data(imu_data, force_data)\n    \n    # Compute balance torques\n    torques = controller.compute_balance_torques()\n    print(f"Required balance torques: Roll = {torques[0]:.2f} Nm, Pitch = {torques[1]:.2f} Nm")\n'})}),"\n",(0,r.jsx)(n.h3,{id:"advanced-balance-control-lqr-based-approach",children:"Advanced Balance Control: LQR-Based Approach"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'class LQRBalanceController:\n    def __init__(self, robot_params):\n        """\n        Initialize LQR-based balance controller\n        \n        Args:\n            robot_params: Dictionary containing robot parameters\n        """\n        self.mass = robot_params.get(\'total_mass\', 50.0)\n        self.com_height = robot_params.get(\'com_height\', 0.8)\n        self.gravity = 9.81\n        self.tau = np.sqrt(self.com_height / self.gravity)  # Time constant\n        \n        # Linearized system matrices around upright position\n        # For inverted pendulum: dx/dt = A*x + B*u\n        # Where x = [com_pos, com_vel], u = [control_input]\n        self.A = np.array([\n            [0, 1],           # d(com_pos)/dt = com_vel\n            [self.gravity/self.com_height, 0]  # d(com_vel)/dt = (g/h)*com_pos\n        ])\n        \n        # This is a simplified model - in practice B would relate control inputs to CoM acceleration\n        self.B = np.array([[0], [1.0]])\n        \n        # Weight matrices for LQR\n        self.Q = np.array([[100, 0], [0, 10]])  # State weights (position, velocity)\n        self.R = np.array([[1]])  # Control effort weight\n        \n        # Compute LQR gain matrix (in a real implementation, this would be precomputed)\n        self.K = self.compute_lqr_gain()\n        \n        # System state [com_position, com_velocity]\n        self.state = np.array([0.0, 0.0])\n    \n    def compute_lqr_gain(self):\n        """\n        Compute LQR gain matrix (in practice, this would be done offline)\n        For this example, we\'ll return a precomputed value\n        """\n        # For the given A, B, Q, R matrices, the LQR solution gives a gain matrix K\n        # This is a simplified representation\n        return np.array([10.0, 2.0])  # [k_pos, k_vel] for u = -K*x\n    \n    def update_state(self, com_pos_error, com_vel):\n        """\n        Update the system state with current CoM error and velocity\n        \n        Args:\n            com_pos_error: Error in CoM position from desired\n            com_vel: CoM velocity\n        """\n        self.state = np.array([com_pos_error, com_vel])\n    \n    def compute_control_action(self):\n        """\n        Compute control action using LQR law: u = -K*x\n        """\n        control_action = -np.dot(self.K, self.state)\n        return control_action\n    \n    def compute_joint_torques(self, control_action):\n        """\n        Convert abstract control action to joint torques\n        This mapping is robot-specific and would need to be calibrated\n        """\n        # Simplified mapping - in reality this would be more complex\n        # and involve inverse kinematics/dynamics\n        hip_roll_torque = control_action * 5.0  # Scale factor\n        ankle_roll_torque = -control_action * 4.0  # Opposing torque for balance\n        \n        return {\n            \'hip_roll\': np.clip(hip_roll_torque, -50.0, 50.0),\n            \'ankle_roll\': np.clip(ankle_roll_torque, -40.0, 40.0)\n        }\n\n# Example usage\nif __name__ == "__main__":\n    robot_params = {\'total_mass\': 50.0, \'com_height\': 0.8}\n    lqr_controller = LQRBalanceController(robot_params)\n    \n    # Simulate a disturbance\n    lqr_controller.update_state(com_pos_error=0.02, com_vel=0.1)  # 2cm CoM error, 0.1 m/s velocity\n    \n    control_action = lqr_controller.compute_control_action()\n    joint_torques = lqr_controller.compute_joint_torques(control_action)\n    \n    print(f"LQR Control action: {control_action:.3f}")\n    print(f"Joint torques: {joint_torques}")\n'})}),"\n",(0,r.jsx)(n.h3,{id:"capture-point-based-balance-recovery",children:"Capture Point-Based Balance Recovery"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'class CapturePointController:\n    def __init__(self, robot_params):\n        """\n        Initialize Capture Point-based balance controller\n        \n        Args:\n            robot_params: Dictionary containing robot parameters\n        """\n        self.com_height = robot_params.get(\'com_height\', 0.8)\n        self.gravity = 9.81\n        self.tau = np.sqrt(self.com_height / self.gravity)  # Time constant\n        self.foot_separation = robot_params.get(\'foot_separation\', 0.2)  # Distance between feet\n        \n        # Foot dimensions for support polygon\n        self.foot_length = robot_params.get(\'foot_length\', 0.25)\n        self.foot_width = robot_params.get(\'foot_width\', 0.1)\n    \n    def calculate_capture_point(self, com_pos, com_vel):\n        """\n        Calculate the capture point where the robot should step to stop\n        \n        Args:\n            com_pos: Current center of mass position [x, y]\n            com_vel: Current center of mass velocity [vx, vy]\n        \n        Returns:\n            Capture point [x, y] coordinates\n        """\n        capture_point_x = com_pos[0] + com_vel[0] * self.tau\n        capture_point_y = com_pos[1] + com_vel[1] * self.tau\n        \n        return np.array([capture_point_x, capture_point_y])\n    \n    def calculate_next_foot_position(self, current_support_pos, com_pos, com_vel):\n        """\n        Determine where to place the next foot based on capture point\n        \n        Args:\n            current_support_pos: Position of current support foot [x, y, z]\n            com_pos: Current CoM position [x, y]\n            com_vel: Current CoM velocity [vx, vy]\n        \n        Returns:\n            Next foot position [x, y, z]\n        """\n        capture_point = self.calculate_capture_point(com_pos, com_vel)\n        \n        # In normal walking, we want to step to a location that maintains balance\n        # but also progresses the gait. For recovery, step toward capture point.\n        \n        # For balance recovery, step as close to capture point as possible\n        # while maintaining feasible step length\n        step_vector = capture_point - current_support_pos[:2]\n        step_distance = np.linalg.norm(step_vector)\n        \n        # Maximum comfortable step distance\n        max_step = 0.4  # meters\n        \n        if step_distance > max_step:\n            # Normalize and scale to maximum step\n            step_vector = step_vector / step_distance * max_step\n        \n        next_foot_pos = current_support_pos.copy()\n        next_foot_pos[:2] = current_support_pos[:2] + step_vector\n        \n        return next_foot_pos\n    \n    def determine_support_polygon(self, left_foot_pos, right_foot_pos):\n        """\n        Calculate the support polygon given both foot positions\n        \n        Args:\n            left_foot_pos: Position of left foot [x, y, z]\n            right_foot_pos: Position of right foot [x, y, z]\n        \n        Returns:\n            Vertices of support polygon\n        """\n        # Simplified: create a rectangle that encompasses both feet\n        # with appropriate foot dimensions\n        \n        # Calculate the center between feet\n        center_x = (left_foot_pos[0] + right_foot_pos[0]) / 2\n        center_y = (left_foot_pos[1] + right_foot_pos[1]) / 2\n        \n        # Calculate the width (distance between feet) and add foot width\n        width = max(abs(left_foot_pos[1] - right_foot_pos[1]), self.foot_width)\n        length = max(abs(left_foot_pos[0] - right_foot_pos[0]) + self.foot_length, 0.3)\n        \n        # Create rectangle vertices\n        vertices = [\n            [center_x - length/2, center_y - width/2, 0],  # Bottom-left\n            [center_x + length/2, center_y - width/2, 0],  # Bottom-right\n            [center_x + length/2, center_y + width/2, 0],  # Top-right\n            [center_x - length/2, center_y + width/2, 0]   # Top-left\n        ]\n        \n        return vertices\n    \n    def is_zmp_stable(self, zmp_pos, support_polygon):\n        """\n        Check if ZMP is within support polygon\n        """\n        # Simplified point-in-polygon test\n        x, y = zmp_pos[0], zmp_pos[1]\n        \n        # Get polygon bounds\n        poly_x = [v[0] for v in support_polygon]\n        poly_y = [v[1] for v in support_polygon]\n        \n        min_x, max_x = min(poly_x), max(poly_x)\n        min_y, max_y = min(poly_y), max(poly_y)\n        \n        return min_x <= x <= max_x and min_y <= y <= max_y\n\n# Example usage\nif __name__ == "__main__":\n    robot_params = {\'com_height\': 0.8, \'foot_separation\': 0.2}\n    cp_controller = CapturePointController(robot_params)\n    \n    # Simulate current state\n    current_com_pos = [0.0, 0.0]  # CoM at origin\n    current_com_vel = [0.3, 0.1]  # Moving forward with slight lateral motion\n    support_foot_pos = [0.0, 0.1, 0.0]  # Right foot at y=0.1\n    \n    # Calculate capture point\n    capture_point = cp_controller.calculate_capture_point(current_com_pos, current_com_vel)\n    print(f"Capture point: {capture_point}")\n    \n    # Determine next foot position\n    next_foot_pos = cp_controller.calculate_next_foot_position(\n        support_foot_pos, current_com_pos, current_com_vel\n    )\n    print(f"Next foot position: {next_foot_pos}")\n'})}),"\n",(0,r.jsx)(n.h3,{id:"model-predictive-control-mpc-for-balance",children:"Model Predictive Control (MPC) for Balance"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'class MPCBalanceController:\n    def __init__(self, robot_params, prediction_horizon=20):\n        """\n        Initialize MPC-based balance controller\n        \n        Args:\n            robot_params: Dictionary containing robot parameters\n            prediction_horizon: Number of steps to predict into the future\n        """\n        self.com_height = robot_params.get(\'com_height\', 0.8)\n        self.gravity = 9.81\n        self.tau = np.sqrt(self.com_height / self.gravity)\n        self.prediction_horizon = prediction_horizon\n        self.dt = 0.05  # Prediction time step (50ms)\n        \n        # Cost function weights\n        self.weight_com = 1.0      # Penalty on CoM deviation\n        self.weight_com_vel = 0.5  # Penalty on CoM velocity\n        self.weight_zmp = 10.0     # Penalty on ZMP deviation\n        self.weight_control = 0.1  # Penalty on control effort\n    \n    def predict_motion(self, initial_state, control_sequence):\n        """\n        Predict future states based on current state and control inputs\n        \n        Args:\n            initial_state: [com_pos, com_vel] at start\n            control_sequence: Sequence of control inputs over prediction horizon\n        \n        Returns:\n            Sequence of predicted states\n        """\n        states = [initial_state]\n        current_state = initial_state.copy()\n        \n        for control_input in control_sequence:\n            # Simplified dynamics model: double integrator with gravity effect\n            # d\xb2x/dt\xb2 = (g/h)*x + u\n            com_acc = (self.gravity / self.com_height) * current_state[0] + control_input\n            new_com_vel = current_state[1] + com_acc * self.dt\n            new_com_pos = current_state[0] + new_com_vel * self.dt\n            \n            current_state = np.array([new_com_pos, new_com_vel])\n            states.append(current_state)\n        \n        return states\n    \n    def compute_control_sequence(self, current_state, desired_trajectory):\n        """\n        Compute optimal control sequence using simplified approach\n        (In practice, this would use quadratic programming)\n        \n        Args:\n            current_state: Current [com_pos, com_vel]\n            desired_trajectory: Desired trajectory over prediction horizon\n        \n        Returns:\n            Optimal control sequence\n        """\n        # This is a simplified implementation\n        # A real MPC would solve an optimization problem\n        control_sequence = []\n        \n        # For demonstration, use a simple tracking approach\n        current_state_copy = current_state.copy()\n        \n        for i in range(self.prediction_horizon):\n            if i < len(desired_trajectory):\n                desired_state = desired_trajectory[i]\n            else:\n                desired_state = desired_trajectory[-1]  # Hold last desired state\n            \n            # Simple proportional control to reach desired state\n            pos_error = desired_state[0] - current_state_copy[0]\n            vel_error = desired_state[1] - current_state_copy[1]\n            \n            # Calculate control input (this is simplified)\n            control_input = 2.0 * pos_error + 1.0 * vel_error\n            \n            # Apply control and update state for next prediction\n            com_acc = (self.gravity / self.com_height) * current_state_copy[0] + control_input\n            new_com_vel = current_state_copy[1] + com_acc * self.dt\n            new_com_pos = current_state_copy[0] + new_com_vel * self.dt\n            \n            current_state_copy = np.array([new_com_pos, new_com_vel])\n            control_sequence.append(control_input)\n        \n        return control_sequence\n\n# Example usage\nif __name__ == "__main__":\n    robot_params = {\'com_height\': 0.8}\n    mpc_controller = MPCBalanceController(robot_params)\n    \n    # Initial state slightly perturbed\n    initial_state = np.array([0.02, 0.05])  # 2cm CoM offset, 5cm/s velocity\n    \n    # Desired trajectory (for stability, keep CoM near zero)\n    desired_trajectory = [np.array([0.0, 0.0]) for _ in range(mpc_controller.prediction_horizon)]\n    \n    # Compute control sequence\n    control_seq = mpc_controller.compute_control_sequence(initial_state, desired_trajectory)\n    print(f"Computed control sequence (first 5 values): {control_seq[:5]}")\n'})}),"\n",(0,r.jsx)(n.h2,{id:"advanced-balance-strategies",children:"Advanced Balance Strategies"}),"\n",(0,r.jsx)(n.h3,{id:"whole-body-balance-control",children:"Whole-Body Balance Control"}),"\n",(0,r.jsx)(n.p,{children:"Managing balance using all available degrees of freedom:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'class WholeBodyBalanceController:\n    def __init__(self, robot_params):\n        self.params = robot_params\n        # This controller would coordinate arms, legs, and torso for balance\n        # Implementation would involve full-body inverse kinematics/dynamics\n    \n    def distribute_balance_control(self, required_com_adjustment):\n        """\n        Distribute balance control across all body parts\n        """\n        # This would involve complex optimization to determine\n        # how to use arms, legs, torso, etc. to maintain balance\n        pass\n'})}),"\n",(0,r.jsx)(n.h3,{id:"disturbance-handling",children:"Disturbance Handling"}),"\n",(0,r.jsx)(n.p,{children:"Robustness against external forces and unexpected events:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'class DisturbanceRejectionController:\n    def __init__(self, robot_params):\n        self.base_controller = SensorBasedBalanceController(robot_params)\n        self.disturbance_threshold = 50.0  # N or Nm threshold for disturbance detection\n        self.recovery_mode = False\n        \n    def handle_disturbance(self, force_torque_data):\n        """Detect and respond to disturbances"""\n        # Calculate magnitude of external forces/torques\n        force_magnitude = np.linalg.norm(force_torque_data[:3])\n        torque_magnitude = np.linalg.norm(force_torque_data[3:])\n        \n        if max(force_magnitude, torque_magnitude) > self.disturbance_threshold:\n            # Significant disturbance detected\n            self.recovery_mode = True\n            return self.execute_recovery_sequence()\n        else:\n            return self.base_controller.compute_balance_torques()\n    \n    def execute_recovery_sequence(self):\n        """Execute predefined recovery actions"""\n        # This would include actions like:\n        # - Widening foot stance\n        # - Taking a recovery step\n        # - Moving arms for balance\n        # - Adjusting body posture\n        pass\n'})}),"\n",(0,r.jsx)(n.h2,{id:"troubleshooting-common-issues",children:"Troubleshooting Common Issues"}),"\n",(0,r.jsx)(n.h3,{id:"oscillations-and-instability",children:"Oscillations and Instability"}),"\n",(0,r.jsx)(n.p,{children:"If the robot exhibits oscillations:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Reduce control gains (especially derivative terms)"}),"\n",(0,r.jsx)(n.li,{children:"Check for sensor noise or delay"}),"\n",(0,r.jsx)(n.li,{children:"Verify mechanical compliance in joints"}),"\n",(0,r.jsx)(n.li,{children:"Ensure proper sensor calibration"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"excessive-joint-torques",children:"Excessive Joint Torques"}),"\n",(0,r.jsx)(n.p,{children:"If computed torques exceed actuator capabilities:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Implement torque limiting in control algorithm"}),"\n",(0,r.jsx)(n.li,{children:"Adjust control gains to reduce required torques"}),"\n",(0,r.jsx)(n.li,{children:"Check for singular configurations"}),"\n",(0,r.jsx)(n.li,{children:"Verify system parameters (mass, CoM height)"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"drifting-behavior",children:"Drifting Behavior"}),"\n",(0,r.jsx)(n.p,{children:"If the robot slowly drifts from position:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Increase integral gain (or implement integral action)"}),"\n",(0,r.jsx)(n.li,{children:"Check for sensor bias or drift"}),"\n",(0,r.jsx)(n.li,{children:"Verify that control objectives are achievable"}),"\n",(0,r.jsx)(n.li,{children:"Adjust desired CoM/ZMP references"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"slow-response-to-perturbations",children:"Slow Response to Perturbations"}),"\n",(0,r.jsx)(n.p,{children:"If the robot reacts too slowly to disturbances:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Increase proportional gains"}),"\n",(0,r.jsx)(n.li,{children:"Implement feedforward control for known disturbances"}),"\n",(0,r.jsx)(n.li,{children:"Reduce control loop delay"}),"\n",(0,r.jsx)(n.li,{children:"Consider predictive control approaches"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsx)(n.h3,{id:"robust-control-design",children:"Robust Control Design"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Implement multiple control strategies and switch between them based on conditions"}),"\n",(0,r.jsx)(n.li,{children:"Design controllers with proper safety margins"}),"\n",(0,r.jsx)(n.li,{children:"Include control authority limitations in design"}),"\n",(0,r.jsx)(n.li,{children:"Test controllers across different operating conditions"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"sensor-integration",children:"Sensor Integration"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Use multiple sensors with sensor fusion for robust state estimation"}),"\n",(0,r.jsx)(n.li,{children:"Implement sensor health monitoring"}),"\n",(0,r.jsx)(n.li,{children:"Calibrate sensors regularly"}),"\n",(0,r.jsx)(n.li,{children:"Account for sensor delays in control design"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"safety-considerations",children:"Safety Considerations"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Implement emergency stop procedures"}),"\n",(0,r.jsx)(n.li,{children:"Design graceful degradation when sensors fail"}),"\n",(0,r.jsx)(n.li,{children:"Include maximum joint limit safety checks"}),"\n",(0,r.jsx)(n.li,{children:"Plan for safe fall or shutdown procedures"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"validation-and-testing",children:"Validation and Testing"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Test in simulation before hardware deployment"}),"\n",(0,r.jsx)(n.li,{children:"Start with conservative parameters"}),"\n",(0,r.jsx)(n.li,{children:"Gradually increase performance requirements"}),"\n",(0,r.jsx)(n.li,{children:"Test with various perturbations and scenarios"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"hands-on-exercise",children:"Hands-on Exercise"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Balance Controller Design"}),": Design and implement a PID-based balance controller for a simulated humanoid robot. Test its response to various perturbations."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"ZMP Stability Analysis"}),": Implement the ZMP calculation and verify that it remains within the support polygon during different standing and walking conditions."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Capture Point Simulation"}),": Create a simulation that calculates the capture point for different CoM positions and velocities, and verify that stepping to this point stops the robot's motion."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Perturbation Response"}),": Implement a controller that handles external disturbances by adjusting the next step location based on balance requirements."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Multi-Strategy Control"}),": Combine multiple control strategies (e.g., PID and LQR) and implement logic to switch between them based on operating conditions."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Balance control is fundamental to humanoid robot functionality"}),"\n",(0,r.jsx)(n.li,{children:"Multiple control strategies exist for different scenarios"}),"\n",(0,r.jsx)(n.li,{children:"Sensor quality directly impacts control performance"}),"\n",(0,r.jsx)(n.li,{children:"Stability margins are crucial for robust operation"}),"\n",(0,r.jsx)(n.li,{children:"Disturbance rejection is essential for real-world applications"}),"\n",(0,r.jsx)(n.li,{children:"Proper validation and safety measures are critical"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:'"Feedback Control for Humanoid Robot Balance" - Technical papers'}),"\n",(0,r.jsx)(n.li,{children:'"Model Predictive Control for Humanoid Balance" - Research literature'}),"\n",(0,r.jsx)(n.li,{children:'"Robust Control of Underactuated Systems" - Advanced control theory'}),"\n",(0,r.jsx)(n.li,{children:'"Humanoid Robotics: A Reference" - Comprehensive reference text'}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,r.jsx)(n.p,{children:"Continue to Chapter 4: Humanoid Manipulation to explore how balance control integrates with manipulation tasks."})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>a,x:()=>s});var t=o(6540);const r={},i=t.createContext(r);function a(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);