"use strict";(globalThis.webpackChunkphysical_ai_robotics_book=globalThis.webpackChunkphysical_ai_robotics_book||[]).push([[2500],{1493:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>t,contentTitle:()=>l,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"appendix-b-setup/gazebo-setup","title":"Gazebo Setup","description":"This chapter provides comprehensive instructions for setting up Gazebo simulation environments for Physical AI and humanoid robotics applications. Gazebo is a critical tool for testing robotics algorithms in safe, repeatable environments before deployment to physical hardware.","source":"@site/docs/appendix-b-setup/03-gazebo-setup.md","sourceDirName":"appendix-b-setup","slug":"/appendix-b-setup/gazebo-setup","permalink":"/Physical_AI_And_Humanoid_Robotics_Book/docs/appendix-b-setup/gazebo-setup","draft":false,"unlisted":false,"editUrl":"https://github.com/Tayyaba-Akbar956/Physical_AI_And_Humanoid_Robotics_Book/tree/main/docs/appendix-b-setup/03-gazebo-setup.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"Gazebo Setup"},"sidebar":"tutorialSidebar","previous":{"title":"ROS 2 Setup","permalink":"/Physical_AI_And_Humanoid_Robotics_Book/docs/appendix-b-setup/ros2-setup"},"next":{"title":"Isaac Sim Setup","permalink":"/Physical_AI_And_Humanoid_Robotics_Book/docs/appendix-b-setup/isaac-setup"}}');var o=i(4848),a=i(8453);const r={sidebar_position:3,title:"Gazebo Setup"},l="Gazebo Setup for Physical AI Simulation",t={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction: Simulation in Physical AI Development",id:"introduction-simulation-in-physical-ai-development",level:2},{value:"Installing Gazebo Garden",id:"installing-gazebo-garden",level:2},{value:"Prerequisites",id:"prerequisites",level:3},{value:"Installation Methods",id:"installation-methods",level:3},{value:"Method 1: Package Installation (Recommended)",id:"method-1-package-installation-recommended",level:4},{value:"Method 2: Build from Source (Advanced)",id:"method-2-build-from-source-advanced",level:4},{value:"Verification",id:"verification",level:3},{value:"Understanding Gazebo Architecture",id:"understanding-gazebo-architecture",level:2},{value:"Core Components",id:"core-components",level:3},{value:"SDF (Simulation Description Format)",id:"sdf-simulation-description-format",level:3},{value:"Configuring Gazebo for Physical AI",id:"configuring-gazebo-for-physical-ai",level:2},{value:"Performance Optimization Settings",id:"performance-optimization-settings",level:3},{value:"Graphics Configuration",id:"graphics-configuration",level:3},{value:"Creating Robot Models for Gazebo",id:"creating-robot-models-for-gazebo",level:2},{value:"URDF to SDF Conversion",id:"urdf-to-sdf-conversion",level:3},{value:"SDF World File",id:"sdf-world-file",level:3},{value:"Gazebo-ROS 2 Integration",id:"gazebo-ros-2-integration",level:2},{value:"Installing Gazebo ROS 2 Bridge",id:"installing-gazebo-ros-2-bridge",level:3},{value:"Creating Controller Configuration",id:"creating-controller-configuration",level:3},{value:"Launch File for Gazebo Integration",id:"launch-file-for-gazebo-integration",level:3},{value:"Physics Configuration for Physical AI",id:"physics-configuration-for-physical-ai",level:2},{value:"Understanding Physics Parameters",id:"understanding-physics-parameters",level:3},{value:"Tuning Physics for Realistic Behavior",id:"tuning-physics-for-realistic-behavior",level:3},{value:"Sensor Simulation in Gazebo",id:"sensor-simulation-in-gazebo",level:2},{value:"Camera Simulation",id:"camera-simulation",level:3},{value:"LiDAR Simulation",id:"lidar-simulation",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Simulation Performance Tuning",id:"simulation-performance-tuning",level:3},{value:"Command Line Performance Options",id:"command-line-performance-options",level:3},{value:"Debugging and Troubleshooting",id:"debugging-and-troubleshooting",level:2},{value:"Common Simulation Issues",id:"common-simulation-issues",level:3},{value:"Issue 1: Robot Falls Through Ground",id:"issue-1-robot-falls-through-ground",level:4},{value:"Issue 2: Joint Jitters or Oscillates",id:"issue-2-joint-jitters-or-oscillates",level:4},{value:"Issue 3: High CPU Usage",id:"issue-3-high-cpu-usage",level:4},{value:"Debugging Tools",id:"debugging-tools",level:3},{value:"Using Gazebo GUI for Debugging",id:"using-gazebo-gui-for-debugging",level:4},{value:"Command Line Debugging",id:"command-line-debugging",level:4},{value:"Advanced Simulation Techniques",id:"advanced-simulation-techniques",level:2},{value:"Creating Complex Environments",id:"creating-complex-environments",level:3},{value:"Custom Sensor Plugins",id:"custom-sensor-plugins",level:3},{value:"Physics Plugin Development",id:"physics-plugin-development",level:3},{value:"Testing Physical AI Algorithms",id:"testing-physical-ai-algorithms",level:2},{value:"Simulation-Based Testing",id:"simulation-based-testing",level:3},{value:"Key Takeaways",id:"key-takeaways",level:2},{value:"Further Reading",id:"further-reading",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"gazebo-setup-for-physical-ai-simulation",children:"Gazebo Setup for Physical AI Simulation"})}),"\n",(0,o.jsx)(e.p,{children:"This chapter provides comprehensive instructions for setting up Gazebo simulation environments for Physical AI and humanoid robotics applications. Gazebo is a critical tool for testing robotics algorithms in safe, repeatable environments before deployment to physical hardware."}),"\n",(0,o.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Install and configure Gazebo Garden for Physical AI applications"}),"\n",(0,o.jsx)(e.li,{children:"Create custom robot models and environments for simulation"}),"\n",(0,o.jsx)(e.li,{children:"Integrate Gazebo with ROS 2 for seamless simulation-control workflows"}),"\n",(0,o.jsx)(e.li,{children:"Understand physics parameters and their impact on robot behavior"}),"\n",(0,o.jsx)(e.li,{children:"Troubleshoot common simulation issues and optimize performance"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"introduction-simulation-in-physical-ai-development",children:"Introduction: Simulation in Physical AI Development"}),"\n",(0,o.jsx)(e.p,{children:"Simulation is fundamental to Physical AI development, enabling:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Safe Testing"}),": Test algorithms without risk of damaging hardware"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Repeatability"}),": Run experiments multiple times under identical conditions"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Cost Efficiency"}),": Develop without expensive physical robots"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Scalability"}),": Test multi-robot scenarios efficiently"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Rapid Prototyping"}),": Quickly iterate on control and perception algorithms"]}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"For Physical AI applications, simulation must accurately model the physical world including:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Physics: Gravity, friction, collision dynamics"}),"\n",(0,o.jsx)(e.li,{children:"Sensors: Camera, LiDAR, IMU, force/torque sensing"}),"\n",(0,o.jsx)(e.li,{children:"Environment: Lighting, textures, and physical interactions"}),"\n",(0,o.jsx)(e.li,{children:"Real-time constraints: Proper timing for control systems"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"installing-gazebo-garden",children:"Installing Gazebo Garden"}),"\n",(0,o.jsx)(e.h3,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,o.jsx)(e.p,{children:"Ensure your system meets Gazebo requirements:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Operating System"}),": Ubuntu 22.04 (recommended)"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Graphics"}),": OpenGL 2.1+ compatible GPU with dedicated VRAM"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Memory"}),": 8+ GB RAM (16+ GB recommended for complex scenes)"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Storage"}),": 5+ GB free space"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"installation-methods",children:"Installation Methods"}),"\n",(0,o.jsx)(e.h4,{id:"method-1-package-installation-recommended",children:"Method 1: Package Installation (Recommended)"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"# Add Gazebo package repository\ncurl -sSL http://get.gazebosim.org | sh\n\n# Install Gazebo Garden\nsudo apt install gazebo-garden\n"})}),"\n",(0,o.jsx)(e.h4,{id:"method-2-build-from-source-advanced",children:"Method 2: Build from Source (Advanced)"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"# Install build dependencies\nsudo apt update\nsudo apt install -y \\\n    build-essential \\\n    cmake \\\n    cppcheck \\\n    doxygen \\\n    git \\\n    libaom-dev \\\n    libavcodec-dev \\\n    libavdevice-dev \\\n    libavformat-dev \\\n    libavutil-dev \\\n    libbz2-dev \\\n    libcurl4-openssl-dev \\\n    libeigen3-dev \\\n    libfreeimage-dev \\\n    libgazebo11-dev \\\n    libgstreamer1.0-dev \\\n    libignition-cmake2-dev \\\n    libignition-common-dev \\\n    libignition-fuel-tools-dev \\\n    libignition-gui-dev \\\n    libignition-launch-dev \\\n    libignition-math6-dev \\\n    libignition-msgs-dev \\\n    libignition-physics-dev \\\n    libignition-rendering-dev \\\n    libignition-sensors-dev \\\n    libignition-tools-dev \\\n    libignition-transport-dev \\\n    libjxr-dev \\\n    libogre-1.12-dev \\\n    libogre-2.2-dev \\\n    libopencv-dev \\\n    libpcl-dev \\\n    libqt5core5a \\\n    libqt5gui5 \\\n    libqt5opengl5-dev \\\n    libqt5widgets5 \\\n    libsdformat13-dev \\\n    libswscale-dev \\\n    libtinyxml2-dev \\\n    libxml2-dev \\\n    pkg-config \\\n    python3-dev \\\n    python3-pip \\\n    python3-rosdep \\\n    python3-setuptools \\\n    software-properties-common \\\n    wget\n\n# Clone and build Gazebo Garden\ngit clone https://github.com/gazebosim/gz-sim.git\ncd gz-sim\ngit checkout gz-sim7\nmkdir build\ncd build\ncmake .. -DCMAKE_BUILD_TYPE=Release\nmake -j$(nproc)\nsudo make install\n"})}),"\n",(0,o.jsx)(e.h3,{id:"verification",children:"Verification"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"# Check Gazebo installation\ngz --version\n\n# Test basic functionality\ngz sim --headless-testing\n"})}),"\n",(0,o.jsx)(e.h2,{id:"understanding-gazebo-architecture",children:"Understanding Gazebo Architecture"}),"\n",(0,o.jsx)(e.h3,{id:"core-components",children:"Core Components"}),"\n",(0,o.jsx)(e.p,{children:"Gazebo consists of several interconnected libraries:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Gz-Sim"}),": Simulation execution engine"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Gz-Physics"}),": Physics simulation backend"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Gz-Rendering"}),": Graphics rendering"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Gz-Sensors"}),": Sensor simulation"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Gz-Transport"}),": Message passing between components"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"sdf-simulation-description-format",children:"SDF (Simulation Description Format)"}),"\n",(0,o.jsx)(e.p,{children:"SDF is XML-based format for describing simulation environments:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0" ?>\n<sdf version="1.10">\n  <world name="default">\n    \x3c!-- World properties --\x3e\n    <physics type="ode">\n      <gravity>0 0 -9.8</gravity>\n    </physics>\n    \n    \x3c!-- Models in the world --\x3e\n    <model name="ground_plane">\n      <pose>0 0 0 0 0 0</pose>\n      <link name="link">\n        <collision name="collision">\n          <geometry>\n            <plane>\n              <normal>0 0 1</normal>\n            </plane>\n          </geometry>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <plane>\n              <normal>0 0 1</normal>\n              <size>100 100</size>\n            </plane>\n          </geometry>\n        </visual>\n      </link>\n    </model>\n  </world>\n</sdf>\n'})}),"\n",(0,o.jsx)(e.h2,{id:"configuring-gazebo-for-physical-ai",children:"Configuring Gazebo for Physical AI"}),"\n",(0,o.jsx)(e.h3,{id:"performance-optimization-settings",children:"Performance Optimization Settings"}),"\n",(0,o.jsxs)(e.p,{children:["Create or edit ",(0,o.jsx)(e.code,{children:"~/.gz/fuel/config.yaml"}),":"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-yaml",children:"# Fuel configuration for Gazebo\ncache_path: ~/.gz/fuel\nservers:\n  - url: https://fuel.gazebosim.org\n    version: 1\n\n# Performance settings\nsettings:\n  # Reduce simulation step size for accuracy\n  max_step_size: 0.001\n  # Real-time update rate\n  real_time_update_rate: 1000\n  # Gravity (Earth standard)\n  gravity: [0, 0, -9.8]\n"})}),"\n",(0,o.jsx)(e.h3,{id:"graphics-configuration",children:"Graphics Configuration"}),"\n",(0,o.jsx)(e.p,{children:"For optimal rendering performance, configure your graphics settings:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"# Check graphics configuration\nlspci | grep -E \"VGA|3D\"\nnvidia-smi  # If using NVIDIA\n\n# Set environment variables for graphics\necho 'export MESA_GL_VERSION_OVERRIDE=3.3' >> ~/.bashrc\necho 'export LIBGL_ALWAYS_SOFTWARE=0' >> ~/.bashrc  # Use hardware acceleration\n"})}),"\n",(0,o.jsx)(e.h2,{id:"creating-robot-models-for-gazebo",children:"Creating Robot Models for Gazebo"}),"\n",(0,o.jsx)(e.h3,{id:"urdf-to-sdf-conversion",children:"URDF to SDF Conversion"}),"\n",(0,o.jsxs)(e.p,{children:["Gazebo uses SDF, but ROS 2 typically uses URDF. Create a simple URDF robot model in ",(0,o.jsx)(e.code,{children:"~/physical_ai_ws/src/robot_models/urdf/physical_robot.urdf"}),":"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="physical_robot" xmlns:xacro="http://www.ros.org/wiki/xacro">\n  \x3c!-- Base Link --\x3e\n  <link name="base_link">\n    <visual>\n      <geometry>\n        <box size="0.5 0.3 0.2"/>\n      </geometry>\n      <material name="blue">\n        <color rgba="0 0 1 1"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <box size="0.5 0.3 0.2"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="10"/>\n      <inertia ixx="1.0" ixy="0.0" ixz="0.0" iyy="1.0" iyz="0.0" izz="1.0"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Wheels --\x3e\n  <link name="wheel_left">\n    <visual>\n      <geometry>\n        <cylinder radius="0.1" length="0.05"/>\n      </geometry>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder radius="0.1" length="0.05"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="1"/>\n      <inertia ixx="0.1" ixy="0.0" ixz="0.0" iyy="0.1" iyz="0.0" izz="0.1"/>\n    </inertial>\n  </link>\n\n  <link name="wheel_right">\n    <visual>\n      <geometry>\n        <cylinder radius="0.1" length="0.05"/>\n      </geometry>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder radius="0.1" length="0.05"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="1"/>\n      <inertia ixx="0.1" ixy="0.0" ixz="0.0" iyy="0.1" iyz="0.0" izz="0.1"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Joints --\x3e\n  <joint name="base_to_wheel_left" type="continuous">\n    <parent link="base_link"/>\n    <child link="wheel_left"/>\n    <origin xyz="-0.2 0.2 -0.1"/>\n    <axis xyz="0 1 0"/>\n  </joint>\n\n  <joint name="base_to_wheel_right" type="continuous">\n    <parent link="base_link"/>\n    <child link="wheel_right"/>\n    <origin xyz="-0.2 -0.2 -0.1"/>\n    <axis xyz="0 1 0"/>\n  </joint>\n\n  \x3c!-- Gazebo plugins --\x3e\n  <gazebo>\n    <plugin filename="libgazebo_ros2_control.so" name="gazebo_ros2_control">\n      <parameters>$(find physical_robot_control)/config/physical_robot_controllers.yaml</parameters>\n    </plugin>\n  </gazebo>\n\n  <gazebo reference="base_link">\n    <mu1>0.2</mu1>\n    <mu2>0.2</mu2>\n  </gazebo>\n\n  <gazebo reference="wheel_left">\n    <mu1>0.8</mu1>\n    <mu2>0.8</mu2>\n    <kp>1000000.0</kp>\n    <kd>100.0</kd>\n  </gazebo>\n\n  <gazebo reference="wheel_right">\n    <mu1>0.8</mu1>\n    <mu2>0.8</mu2>\n    <kp>1000000.0</kp>\n    <kd>100.0</kd>\n  </gazebo>\n</robot>\n'})}),"\n",(0,o.jsx)(e.h3,{id:"sdf-world-file",children:"SDF World File"}),"\n",(0,o.jsxs)(e.p,{children:["Create a simulation world in ",(0,o.jsx)(e.code,{children:"~/physical_ai_ws/src/simulation_packages/worlds/physical_ai_world.sdf"}),":"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0" ?>\n<sdf version="1.10">\n  <world name="physical_ai_world">\n    \x3c!-- Physics Engine --\x3e\n    <physics type="ode">\n      <gravity>0 0 -9.8</gravity>\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1.0</real_time_factor>\n      <real_time_update_rate>1000</real_time_update_rate>\n    </physics>\n\n    \x3c!-- Lighting --\x3e\n    <light name="sun" type="directional">\n      <cast_shadows>true</cast_shadows>\n      <pose>0 0 10 0 0 0</pose>\n      <diffuse>0.8 0.8 0.8 1</diffuse>\n      <specular>0.2 0.2 0.2 1</specular>\n      <attenuation>\n        <range>1000</range>\n        <constant>0.9</constant>\n        <linear>0.01</linear>\n        <quadratic>0.001</quadratic>\n      </attenuation>\n      <direction>-0.2 -0.4 -0.9</direction>\n    </light>\n\n    \x3c!-- Ground Plane --\x3e\n    <model name="ground_plane">\n      <static>true</static>\n      <link name="link">\n        <collision name="collision">\n          <geometry>\n            <plane>\n              <normal>0 0 1</normal>\n              <size>100 100</size>\n            </plane>\n          </geometry>\n          <surface>\n            <friction>\n              <ode>\n                <mu>1.0</mu>\n                <mu2>1.0</mu2>\n              </ode>\n            </friction>\n          </surface>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <plane>\n              <normal>0 0 1</normal>\n              <size>100 100</size>\n            </plane>\n          </geometry>\n          <material>\n            <ambient>0.8 0.8 0.8 1</ambient>\n            <diffuse>0.8 0.8 0.8 1</diffuse>\n          </material>\n        </visual>\n      </link>\n    </model>\n\n    \x3c!-- Sample obstacles --\x3e\n    <model name="obstacle_1">\n      <pose>2 2 0.5 0 0 0</pose>\n      <link name="link">\n        <collision name="collision">\n          <geometry>\n            <box>\n              <size>1 0.5 1</size>\n            </box>\n          </geometry>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <box>\n              <size>1 0.5 1</size>\n            </box>\n          </geometry>\n          <material>\n            <ambient>1 0 0 1</ambient>\n            <diffuse>1 0 0 1</diffuse>\n          </material>\n        </visual>\n        <inertial>\n          <mass>10</mass>\n          <inertia ixx="1" ixy="0" ixz="0" iyy="1" iyz="0" izz="1"/>\n        </inertial>\n      </link>\n    </model>\n\n    \x3c!-- Sample ramp --\x3e\n    <model name="ramp">\n      <pose>5 0 0 0 0.3 0</pose>\n      <link name="link">\n        <collision name="collision">\n          <geometry>\n            <box>\n              <size>2 2 0.2</size>\n            </box>\n          </geometry>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <box>\n              <size>2 2 0.2</size>\n            </box>\n          </geometry>\n          <material>\n            <ambient>0.5 0.5 0.5 1</ambient>\n            <diffuse>0.5 0.5 0.5 1</diffuse>\n          </material>\n        </visual>\n        <inertial>\n          <mass>5</mass>\n          <inertia ixx="1" ixy="0" ixz="0" iyy="1" iyz="0" izz="1"/>\n        </inertial>\n      </link>\n    </model>\n  </world>\n</sdf>\n'})}),"\n",(0,o.jsx)(e.h2,{id:"gazebo-ros-2-integration",children:"Gazebo-ROS 2 Integration"}),"\n",(0,o.jsx)(e.h3,{id:"installing-gazebo-ros-2-bridge",children:"Installing Gazebo ROS 2 Bridge"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"# Install Gazebo ROS 2 packages\nsudo apt install \\\n    ros-humble-gazebo-ros \\\n    ros-humble-gazebo-ros2-control \\\n    ros-humble-gazebo-plugins \\\n    ros-humble-ros2-control \\\n    ros-humble-ros2-controllers \\\n    ros-humble-joint-state-broadcaster \\\n    ros-humble-velocity-controllers \\\n    ros-humble-effort-controllers \\\n    ros-humble-xacro\n"})}),"\n",(0,o.jsx)(e.h3,{id:"creating-controller-configuration",children:"Creating Controller Configuration"}),"\n",(0,o.jsxs)(e.p,{children:["Create ",(0,o.jsx)(e.code,{children:"~/physical_ai_ws/src/control_packages/config/physical_robot_controllers.yaml"}),":"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-yaml",children:"controller_manager:\n  ros__parameters:\n    update_rate: 100  # Hz\n\n    joint_state_broadcaster:\n      type: joint_state_broadcaster/JointStateBroadcaster\n\n    velocity_controller:\n      type: velocity_controllers/JointGroupVelocityController\n\nvelocity_controller:\n  ros__parameters:\n    joints:\n      - base_to_wheel_left\n      - base_to_wheel_right\n"})}),"\n",(0,o.jsx)(e.h3,{id:"launch-file-for-gazebo-integration",children:"Launch File for Gazebo Integration"}),"\n",(0,o.jsxs)(e.p,{children:["Create ",(0,o.jsx)(e.code,{children:"~/physical_ai_ws/src/simulation_packages/launch/gazebo_simulation.launch.py"}),":"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"import os\nfrom launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument, IncludeLaunchDescription\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch.substitutions import LaunchConfiguration\nfrom launch_ros.actions import Node\nfrom ament_index_python.packages import get_package_share_directory\n\ndef generate_launch_description():\n    # Launch arguments\n    use_sim_time = LaunchConfiguration('use_sim_time')\n    world = LaunchConfiguration('world')\n    \n    # Declare launch arguments\n    declare_use_sim_time = DeclareLaunchArgument(\n        'use_sim_time',\n        default_value='true',\n        description='Use simulation (Gazebo) clock if true'\n    )\n    \n    declare_world = DeclareLaunchArgument(\n        'world',\n        default_value=os.path.join(\n            get_package_share_directory('simulation_packages'),\n            'worlds',\n            'physical_ai_world.sdf'\n        ),\n        description='SDF world file'\n    )\n    \n    # Gazebo launch\n    gazebo = IncludeLaunchDescription(\n        PythonLaunchDescriptionSource(\n            os.path.join(\n                get_package_share_directory('gazebo_ros'),\n                'launch',\n                'gazebo.launch.py'\n            )\n        ),\n        launch_arguments={\n            'world': world,\n            'use_sim_time': use_sim_time,\n        }.items(),\n    )\n    \n    # Robot state publisher\n    robot_state_publisher = Node(\n        package='robot_state_publisher',\n        executable='robot_state_publisher',\n        name='robot_state_publisher',\n        output='screen',\n        parameters=[{\n            'use_sim_time': use_sim_time,\n            'robot_description': open(\n                os.path.join(\n                    get_package_share_directory('robot_models'),\n                    'urdf',\n                    'physical_robot.urdf'\n                )\n            ).read()\n        }]\n    )\n    \n    # Spawn robot in Gazebo\n    spawn_entity = Node(\n        package='gazebo_ros',\n        executable='spawn_entity.py',\n        arguments=[\n            '-topic', 'robot_description',\n            '-entity', 'physical_robot',\n            '-x', '0.0',\n            '-y', '0.0',\n            '-z', '0.5'\n        ],\n        output='screen'\n    )\n    \n    # Controller manager\n    controller_manager = Node(\n        package='controller_manager',\n        executable='ros2_control_node',\n        parameters=[\n            os.path.join(\n                get_package_share_directory('control_packages'),\n                'config',\n                'physical_robot_controllers.yaml'\n            )\n        ],\n        output='screen'\n    )\n    \n    return LaunchDescription([\n        declare_use_sim_time,\n        declare_world,\n        gazebo,\n        robot_state_publisher,\n        spawn_entity,\n        controller_manager\n    ])\n"})}),"\n",(0,o.jsx)(e.h2,{id:"physics-configuration-for-physical-ai",children:"Physics Configuration for Physical AI"}),"\n",(0,o.jsx)(e.h3,{id:"understanding-physics-parameters",children:"Understanding Physics Parameters"}),"\n",(0,o.jsx)(e.p,{children:"Physics parameters control how objects behave in simulation:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Gravity"}),": Default is Earth's gravity (-9.8 m/s\xb2 in Z direction)"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Friction"}),": Determines how objects interact with surfaces"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Damping"}),": Simulates energy loss through motion"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Stiffness"}),": How resistant objects are to deformation"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Collision Detection"}),": How collisions are handled"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"tuning-physics-for-realistic-behavior",children:"Tuning Physics for Realistic Behavior"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Example physics configuration in SDF --\x3e\n<physics type="ode">\n  \x3c!-- Gravity --\x3e\n  <gravity>0 0 -9.8</gravity>\n  \n  \x3c!-- Solver parameters --\x3e\n  <ode>\n    <solver>\n      <type>quick</type>\n      <iters>10</iters>\n      <sor>1.3</sor>\n    </solver>\n    \n    \x3c!-- Constraints --\x3e\n    <constraints>\n      <cfm>0.000001</cfm>\n      <erp>0.2</erp>\n      <contact_surface_layer>0.001</contact_surface_layer>\n      <contact_max_correcting_vel>100</contact_max_correcting_vel>\n    </constraints>\n  </ode>\n</physics>\n'})}),"\n",(0,o.jsx)(e.p,{children:"For humanoid robots, consider these parameters:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Higher friction"})," for feet to prevent slipping"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Proper mass distribution"})," for balance"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Appropriate damping"})," to avoid oscillations"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Realistic joint limits"})," to prevent damage"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"sensor-simulation-in-gazebo",children:"Sensor Simulation in Gazebo"}),"\n",(0,o.jsx)(e.h3,{id:"camera-simulation",children:"Camera Simulation"}),"\n",(0,o.jsx)(e.p,{children:"Add camera sensors to your robot model:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'<link name="camera_link">\n  <visual>\n    <geometry>\n      <box size="0.05 0.05 0.05"/>\n    </geometry>\n  </visual>\n  <collision>\n    <geometry>\n      <box size="0.05 0.05 0.05"/>\n    </geometry>\n  </collision>\n  <inertial>\n    <mass value="0.1"/>\n    <inertia ixx="0.001" ixy="0" ixz="0" iyy="0.001" iyz="0" izz="0.001"/>\n  </inertial>\n</link>\n\n<joint name="camera_joint" type="fixed">\n  <parent link="base_link"/>\n  <child link="camera_link"/>\n  <origin xyz="0.2 0 0.1" rpy="0 0 0"/>\n</joint>\n\n<gazebo reference="camera_link">\n  <sensor name="camera" type="camera">\n    <update_rate>30</update_rate>\n    <camera name="head">\n      <horizontal_fov>1.047</horizontal_fov>\n      <image>\n        <width>640</width>\n        <height>480</height>\n        <format>R8G8B8</format>\n      </image>\n      <clip>\n        <near>0.1</near>\n        <far>100</far>\n      </clip>\n    </camera>\n    <plugin name="camera_controller" filename="libgazebo_ros_camera.so">\n      <frame_name>camera_link</frame_name>\n      <topic_name>camera/image_raw</topic_name>\n    </plugin>\n  </sensor>\n</gazebo>\n'})}),"\n",(0,o.jsx)(e.h3,{id:"lidar-simulation",children:"LiDAR Simulation"}),"\n",(0,o.jsx)(e.p,{children:"Add LiDAR sensors:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'<link name="lidar_link">\n  <visual>\n    <geometry>\n      <cylinder radius="0.05" length="0.05"/>\n    </geometry>\n  </visual>\n  <collision>\n    <geometry>\n      <cylinder radius="0.05" length="0.05"/>\n    </geometry>\n  </collision>\n  <inertial>\n    <mass value="0.2"/>\n    <inertia ixx="0.001" ixy="0" ixz="0" iyy="0.001" iyz="0" izz="0.002"/>\n  </inertial>\n</link>\n\n<joint name="lidar_joint" type="fixed">\n  <parent link="base_link"/>\n  <child link="lidar_link"/>\n  <origin xyz="0.2 0 0.2" rpy="0 0 0"/>\n</joint>\n\n<gazebo reference="lidar_link">\n  <sensor name="lidar" type="ray">\n    <update_rate>10</update_rate>\n    <ray>\n      <scan>\n        <horizontal>\n          <samples>720</samples>\n          <resolution>1</resolution>\n          <min_angle>-1.570796</min_angle>\n          <max_angle>1.570796</max_angle>\n        </horizontal>\n      </scan>\n      <range>\n        <min>0.1</min>\n        <max>30.0</max>\n        <resolution>0.01</resolution>\n      </range>\n    </ray>\n    <plugin name="lidar_controller" filename="libgazebo_ros_ray_sensor.so">\n      <ros>\n        <namespace>/physical_robot</namespace>\n        <remapping>~/out:=scan</remapping>\n      </ros>\n      <output_type>sensor_msgs/LaserScan</output_type>\n    </plugin>\n  </sensor>\n</gazebo>\n'})}),"\n",(0,o.jsx)(e.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,o.jsx)(e.h3,{id:"simulation-performance-tuning",children:"Simulation Performance Tuning"}),"\n",(0,o.jsx)(e.p,{children:"To improve simulation performance:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Reduce Physics Update Rate"}),": For less demanding applications"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Simplify Collision Models"}),": Use simpler shapes where possible"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Adjust Visual Quality"}),": Lower quality for headless simulations"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Limit Sensor Frequency"}),": Reduce sensor update rates when possible"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"command-line-performance-options",children:"Command Line Performance Options"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"# Run Gazebo in headless mode (no GUI)\ngz sim -s HeadlessSystem <world_file>\n\n# Limit physics update rate\ngz sim -r 100 <world_file>  # 100 Hz physics update\n\n# Enable multi-threading\ngz sim --iterations 1000 <world_file>\n"})}),"\n",(0,o.jsx)(e.h2,{id:"debugging-and-troubleshooting",children:"Debugging and Troubleshooting"}),"\n",(0,o.jsx)(e.h3,{id:"common-simulation-issues",children:"Common Simulation Issues"}),"\n",(0,o.jsx)(e.h4,{id:"issue-1-robot-falls-through-ground",children:"Issue 1: Robot Falls Through Ground"}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Problem"}),": Robot falls through the ground plane\n",(0,o.jsx)(e.strong,{children:"Solution"}),": Check collision properties and mass/inertia:"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'<link name="base_link">\n  \x3c!-- Must have mass and inertia --\x3e\n  <inertial>\n    <mass value="10"/>\n    <inertia ixx="1.0" ixy="0.0" ixz="0.0" iyy="1.0" iyz="0.0" izz="1.0"/>\n  </inertial>\n  \x3c!-- Must have collision geometry --\x3e\n  <collision name="collision">\n    <geometry>\n      <box size="0.5 0.3 0.2"/>\n    </geometry>\n  </collision>\n</link>\n'})}),"\n",(0,o.jsx)(e.h4,{id:"issue-2-joint-jitters-or-oscillates",children:"Issue 2: Joint Jitters or Oscillates"}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Problem"}),": Robot joints vibrate or oscillate\n",(0,o.jsx)(e.strong,{children:"Solution"}),": Adjust physics parameters:"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'<gazebo reference="joint_name">\n  <physics>\n    <ode>\n      <limit>\n        <cfm>0.00001</cfm>  \x3c!-- Constraint Force Mixing --\x3e\n        <erp>0.2</erp>      \x3c!-- Error Reduction Parameter --\x3e\n      </limit>\n      <spring_reference>0</spring_reference>\n      <spring_stiffness>0</spring_stiffness>\n    </ode>\n  </physics>\n</gazebo>\n'})}),"\n",(0,o.jsx)(e.h4,{id:"issue-3-high-cpu-usage",children:"Issue 3: High CPU Usage"}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Problem"}),": Simulation consumes too much CPU\n",(0,o.jsx)(e.strong,{children:"Solution"}),": Optimize parameters:"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"# Reduce physics update rate\nexport GZ_PHYSICS_REAL_TIME_UPDATE_RATE=500\n\n# Use simpler collision shapes\n# Limit number of active sensors\n# Reduce graphics quality for headless operation\n"})}),"\n",(0,o.jsx)(e.h3,{id:"debugging-tools",children:"Debugging Tools"}),"\n",(0,o.jsx)(e.h4,{id:"using-gazebo-gui-for-debugging",children:"Using Gazebo GUI for Debugging"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"# Launch with GUI to visualize physics properties\ngz sim -g <world_file>\n\n# In the GUI, enable:\n# - Contact visualization\n# - Inertia visualization\n# - Joint visualization\n"})}),"\n",(0,o.jsx)(e.h4,{id:"command-line-debugging",children:"Command Line Debugging"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"# Monitor simulation performance\ngz topic -t /stats -n 10\n\n# Check topic connections\nros2 topic list\nros2 topic echo /topic_name\n\n# Monitor physics properties\ngz topic -e /world/<world_name>/model/<model_name>/odometry\n"})}),"\n",(0,o.jsx)(e.h2,{id:"advanced-simulation-techniques",children:"Advanced Simulation Techniques"}),"\n",(0,o.jsx)(e.h3,{id:"creating-complex-environments",children:"Creating Complex Environments"}),"\n",(0,o.jsx)(e.p,{children:"Use Gazebo's Fuel repository for pre-built environments:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"# Browse available models\ngz fuel login\ngz fuel download -u https://fuel.gazebosim.org/1.0/OpenRobotics/models/Construction%20Site\n\n# Use downloaded models in your worlds\n"})}),"\n",(0,o.jsx)(e.h3,{id:"custom-sensor-plugins",children:"Custom Sensor Plugins"}),"\n",(0,o.jsx)(e.p,{children:"Create custom sensor plugins for specialized Physical AI applications:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-cpp",children:"// Example sensor plugin header: physical_ai_sensor.hh\n#include <gazebo/common/Plugin.hh>\n#include <gazebo/sensors/Sensor.hh>\n#include <gazebo/transport/transport.hh>\n\nclass PhysicalAISensor : public gazebo::SensorPlugin\n{\npublic:\n  void Load(gazebo::sensors::SensorPtr _sensor, sdf::ElementPtr _sdf);\n  void OnUpdate();\n\nprivate:\n  gazebo::sensors::SensorPtr sensor;\n  gazebo::transport::NodePtr node;\n  gazebo::transport::PublisherPtr pub;\n  std::string topicName;\n};\n"})}),"\n",(0,o.jsx)(e.h3,{id:"physics-plugin-development",children:"Physics Plugin Development"}),"\n",(0,o.jsx)(e.p,{children:"For custom physics behaviors in Physical AI applications:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-cpp",children:"#include <gazebo/common/Plugin.hh>\n#include <gazebo/physics/physics.hh>\n\nclass PhysicalAIPlugin : public gazebo::WorldPlugin\n{\npublic:\n  void Load(gazebo::physics::WorldPtr _world, sdf::ElementPtr _sdf);\n  void OnUpdate(const gazebo::common::UpdateInfo &_info);\n\nprivate:\n  gazebo::physics::WorldPtr world;\n  gazebo::event::ConnectionPtr updateConnection;\n};\n"})}),"\n",(0,o.jsx)(e.h2,{id:"testing-physical-ai-algorithms",children:"Testing Physical AI Algorithms"}),"\n",(0,o.jsx)(e.h3,{id:"simulation-based-testing",children:"Simulation-Based Testing"}),"\n",(0,o.jsx)(e.p,{children:"Create systematic tests for your Physical AI algorithms:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import Twist\nfrom sensor_msgs.msg import LaserScan\nfrom nav_msgs.msg import Odometry\nimport time\n\nclass SimulationTester(Node):\n    def __init__(self):\n        super().__init__('simulation_tester')\n        \n        # Publishers for commands\n        self.cmd_vel_pub = self.create_publisher(\n            Twist, \n            '/physical_robot/cmd_vel', \n            10\n        )\n        \n        # Subscribers for feedback\n        self.scan_sub = self.create_subscription(\n            LaserScan,\n            '/physical_robot/scan',\n            self.scan_callback,\n            10\n        )\n        \n        self.odom_sub = self.create_subscription(\n            Odometry,\n            '/physical_robot/odom',\n            self.odom_callback,\n            10\n        )\n        \n        # Test parameters\n        self.test_start_time = time.time()\n        self.obstacle_detected = False\n        \n        # Start test sequence\n        self.test_timer = self.create_timer(0.1, self.run_test)\n    \n    def scan_callback(self, msg):\n        # Check for obstacles in front\n        front_scan = msg.ranges[len(msg.ranges)//2 - 90:len(msg.ranges)//2 + 90]\n        if front_scan and min(front_scan) < 0.5:  # Obstacle within 50cm\n            self.obstacle_detected = True\n    \n    def odom_callback(self, msg):\n        # Track position for navigation testing\n        self.current_x = msg.pose.pose.position.x\n        self.current_y = msg.pose.pose.position.y\n    \n    def run_test(self):\n        # Example test: Move forward until obstacle detected\n        cmd = Twist()\n        if not self.obstacle_detected:\n            cmd.linear.x = 0.2  # Move forward\n            cmd.angular.z = 0.0\n            self.get_logger().info('Moving forward...')\n        else:\n            cmd.linear.x = 0.0\n            cmd.angular.z = 0.0\n            self.get_logger().info('Obstacle detected, stopping.')\n            \n            # End test\n            if time.time() - self.test_start_time > 10.0:\n                self.get_logger().info('Test completed successfully')\n                exit(0)\n        \n        self.cmd_vel_pub.publish(cmd)\n\ndef main():\n    rclpy.init()\n    tester = SimulationTester()\n    \n    try:\n        rclpy.spin(tester)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        tester.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,o.jsx)(e.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Gazebo is essential for safe and repeatable Physical AI development"}),"\n",(0,o.jsx)(e.li,{children:"Proper physics configuration is critical for realistic simulation"}),"\n",(0,o.jsx)(e.li,{children:"Sensor simulation enables testing of perception algorithms"}),"\n",(0,o.jsx)(e.li,{children:"Performance optimization is necessary for complex scenarios"}),"\n",(0,o.jsx)(e.li,{children:"Integration with ROS 2 allows seamless development workflows"}),"\n",(0,o.jsx)(e.li,{children:"Systematic testing in simulation improves real-world performance"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:'"Gazebo User Guide": Complete documentation for Gazebo'}),"\n",(0,o.jsx)(e.li,{children:'"Physics Simulation in Robotics": Advanced physics configuration'}),"\n",(0,o.jsx)(e.li,{children:'"Gazebo ROS Integration": Detailed integration techniques'}),"\n",(0,o.jsx)(e.li,{children:'"Simulation-Based Testing for Robotics": Best practices for testing'}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,o.jsx)(e.p,{children:"Continue to Appendix B, Section 4: Isaac Sim Setup to configure the NVIDIA Isaac simulation environment for advanced Physical AI development."})]})}function m(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>r,x:()=>l});var s=i(6540);const o={},a=s.createContext(o);function r(n){const e=s.useContext(a);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:r(n.components),s.createElement(a.Provider,{value:e},n.children)}}}]);