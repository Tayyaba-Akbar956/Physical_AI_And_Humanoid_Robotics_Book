"use strict";(globalThis.webpackChunkphysical_ai_robotics_book=globalThis.webpackChunkphysical_ai_robotics_book||[]).push([[3076],{3683:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"module-02-ros2-middleware/part-01-communication/nodes-topics-services","title":"Nodes, Topics, and Services","description":"This chapter dives deep into the three fundamental communication mechanisms in ROS 2: nodes (computational units), topics (asynchronous communication), and services (synchronous communication). Understanding these concepts is essential for building distributed robotic systems.","source":"@site/docs/module-02-ros2-middleware/part-01-communication/02-nodes-topics-services.md","sourceDirName":"module-02-ros2-middleware/part-01-communication","slug":"/module-02-ros2-middleware/part-01-communication/nodes-topics-services","permalink":"/Physical_AI_And_Humanoid_Robotics_Book/docs/module-02-ros2-middleware/part-01-communication/nodes-topics-services","draft":false,"unlisted":false,"editUrl":"https://github.com/Tayyaba-Akbar956/Physical_AI_And_Humanoid_Robotics_Book/tree/main/docs/module-02-ros2-middleware/part-01-communication/02-nodes-topics-services.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"Nodes, Topics, and Services"},"sidebar":"tutorialSidebar","previous":{"title":"ROS 2 Overview","permalink":"/Physical_AI_And_Humanoid_Robotics_Book/docs/module-02-ros2-middleware/part-01-communication/ros2-overview"},"next":{"title":"Python and rclpy","permalink":"/Physical_AI_And_Humanoid_Robotics_Book/docs/module-02-ros2-middleware/part-01-communication/python-rclpy"}}');var r=s(4848),o=s(8453);const t={sidebar_position:2,title:"Nodes, Topics, and Services"},a="Nodes, Topics, and Services",c={},l=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction: Building Blocks of Communication",id:"introduction-building-blocks-of-communication",level:2},{value:"Core Concepts",id:"core-concepts",level:2},{value:"Nodes: The Computational Foundation",id:"nodes-the-computational-foundation",level:3},{value:"Topics: Asynchronous Data Streams",id:"topics-asynchronous-data-streams",level:3},{value:"Quality of Service (QoS)",id:"quality-of-service-qos",level:3},{value:"Services: Request-Response Communication",id:"services-request-response-communication",level:3},{value:"Actions: Long-running Operations",id:"actions-long-running-operations",level:3},{value:"Practical Implementation",id:"practical-implementation",level:2},{value:"Creating a Node",id:"creating-a-node",level:3},{value:"Creating a Subscriber",id:"creating-a-subscriber",level:3},{value:"Creating a Service",id:"creating-a-service",level:3},{value:"Communication Pattern Selection",id:"communication-pattern-selection",level:3},{value:"Hands-on Exercise",id:"hands-on-exercise",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2},{value:"Further Reading",id:"further-reading",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"nodes-topics-and-services",children:"Nodes, Topics, and Services"})}),"\n",(0,r.jsx)(n.p,{children:"This chapter dives deep into the three fundamental communication mechanisms in ROS 2: nodes (computational units), topics (asynchronous communication), and services (synchronous communication). Understanding these concepts is essential for building distributed robotic systems."}),"\n",(0,r.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Explain the role and implementation of nodes in ROS 2"}),"\n",(0,r.jsx)(n.li,{children:"Implement publishers and subscribers for topic communication"}),"\n",(0,r.jsx)(n.li,{children:"Design and implement services for synchronous communication"}),"\n",(0,r.jsx)(n.li,{children:"Analyze the trade-offs between topics and services"}),"\n",(0,r.jsx)(n.li,{children:"Apply appropriate communication patterns to robot design problems"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"introduction-building-blocks-of-communication",children:"Introduction: Building Blocks of Communication"}),"\n",(0,r.jsx)(n.p,{children:"ROS 2's communication system is built on three primary patterns that handle different types of information exchange:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Nodes"})," provide the computational framework"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Topics"})," enable asynchronous, decoupled data flow"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Services"})," support synchronous request-response interactions"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"These patterns reflect different requirements in robotic systems:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Sensor data flows continuously and asynchronously (topics)"}),"\n",(0,r.jsx)(n.li,{children:"Control commands are often immediate and require confirmation (services)"}),"\n",(0,r.jsx)(n.li,{children:"Different computational tasks run independently but need to share information (nodes)"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,r.jsx)(n.h3,{id:"nodes-the-computational-foundation",children:"Nodes: The Computational Foundation"}),"\n",(0,r.jsx)(n.p,{children:"A ROS 2 node is an instance of a computational process that performs specific tasks in a robot system. Nodes are the containers for your robot's functionality:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Encapsulation"}),": Each node encapsulates specific functionality (navigation, perception, etc.)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Identity"}),": Nodes have unique names within the ROS 2 graph"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Resource management"}),": Nodes manage their own timers, callbacks, and execution contexts"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Communication interface"}),": Nodes contain publishers, subscribers, services, and clients"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Each node operates independently but coordinates with other nodes through the ROS 2 communication infrastructure."}),"\n",(0,r.jsx)(n.h3,{id:"topics-asynchronous-data-streams",children:"Topics: Asynchronous Data Streams"}),"\n",(0,r.jsx)(n.p,{children:"Topics implement a publish-subscribe communication pattern where:"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Publishers"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Send messages to named topics"}),"\n",(0,r.jsx)(n.li,{children:"Don't know or care if there are subscribers"}),"\n",(0,r.jsx)(n.li,{children:"Send data at rates appropriate for the application"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Subscribers"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Receive messages from named topics"}),"\n",(0,r.jsx)(n.li,{children:"Don't know the source of messages"}),"\n",(0,r.jsx)(n.li,{children:"Process messages as they arrive"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Characteristics of Topic Communication"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Loose coupling"}),": Publishers and subscribers don't need to run simultaneously"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Broadcast"}),": One publisher can serve multiple subscribers"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Real-time friendly"}),": Minimal overhead for continuous data streams"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"One-way"}),": Data flows from publisher to subscriber only"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"quality-of-service-qos",children:"Quality of Service (QoS)"}),"\n",(0,r.jsx)(n.p,{children:"ROS 2 topics support Quality of Service settings that control communication behavior:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Reliability"}),": Reliably (all messages delivered) vs. best-effort (some messages may be lost)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Durability"}),": Transient-local (messages stored for late joiners) vs. volatile (no storage)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"History"}),": Keep-all vs. keep-last N messages"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Rate"}),": Maximum rate for throttling messages"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"services-request-response-communication",children:"Services: Request-Response Communication"}),"\n",(0,r.jsx)(n.p,{children:"Services implement synchronous request-response communication:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["A ",(0,r.jsx)(n.strong,{children:"service client"})," sends a request and waits for a response"]}),"\n",(0,r.jsxs)(n.li,{children:["A ",(0,r.jsx)(n.strong,{children:"service server"})," receives the request, processes it, and sends a response"]}),"\n",(0,r.jsx)(n.li,{children:"Communication is point-to-point (one client to one server)"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use cases for services"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Configuration changes that require confirmation"}),"\n",(0,r.jsx)(n.li,{children:"Computations that must complete before proceeding"}),"\n",(0,r.jsx)(n.li,{children:'Discrete actions (e.g., "take snapshot", "calibrate sensor")'}),"\n",(0,r.jsx)(n.li,{children:"Operations where success/failure matters for subsequent actions"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"actions-long-running-operations",children:"Actions: Long-running Operations"}),"\n",(0,r.jsx)(n.p,{children:"Actions are like services but for operations that take significant time:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Clients can send goals and receive feedback during execution"}),"\n",(0,r.jsx)(n.li,{children:"Clients can cancel goals before completion"}),"\n",(0,r.jsx)(n.li,{children:"Useful for navigation tasks, manipulation sequences, or calibration procedures"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"practical-implementation",children:"Practical Implementation"}),"\n",(0,r.jsx)(n.h3,{id:"creating-a-node",children:"Creating a Node"}),"\n",(0,r.jsx)(n.p,{children:"Here's a complete example of a ROS 2 node that publishes sensor data:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# sensor_publisher.py\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import LaserScan\nfrom std_msgs.msg import Header\nimport random\n\nclass SensorPublisher(Node):\n    def __init__(self):\n        super().__init__('laser_sensor_publisher')\n        \n        # Create publisher\n        self.publisher = self.create_publisher(\n            LaserScan, \n            '/scan',  # Topic name\n            10        # Queue size\n        )\n        \n        # Create timer for periodic publishing\n        self.timer = self.create_timer(0.1, self.publish_scan)  # 10 Hz\n        \n        # Sensor parameters\n        self.angle_min = -1.57  # -90 degrees\n        self.angle_max = 1.57   # 90 degrees\n        self.angle_increment = 0.017  # 1 degree\n        self.scan_time = 0.1\n        self.time_increment = 0.0\n        \n    def publish_scan(self):\n        msg = LaserScan()\n        msg.header = Header()\n        msg.header.stamp = self.get_clock().now().to_msg()\n        msg.header.frame_id = 'laser_frame'\n        \n        # Set sensor parameters\n        msg.angle_min = self.angle_min\n        msg.angle_max = self.angle_max\n        msg.angle_increment = self.angle_increment\n        msg.scan_time = self.scan_time\n        msg.time_increment = self.time_increment\n        msg.range_min = 0.1\n        msg.range_max = 10.0\n        \n        # Generate simulated scan data\n        num_readings = int((self.angle_max - self.angle_min) / self.angle_increment) + 1\n        msg.ranges = []\n        for i in range(num_readings):\n            # Simulate distance with some noise\n            distance = 2.0 + random.uniform(-0.1, 0.1)\n            msg.ranges.append(distance)\n        \n        # Publish the message\n        self.publisher.publish(msg)\n        self.get_logger().info(f'Published laser scan with {len(msg.ranges)} readings')\n\ndef main():\n    rclpy.init()\n    node = SensorPublisher()\n    \n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsx)(n.h3,{id:"creating-a-subscriber",children:"Creating a Subscriber"}),"\n",(0,r.jsx)(n.p,{children:"A subscriber node that processes the published laser scan:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# obstacle_detector.py\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import LaserScan\nimport math\n\nclass ObstacleDetector(Node):\n    def __init__(self):\n        super().__init__('obstacle_detector')\n        \n        # Create subscriber\n        self.subscription = self.create_subscription(\n            LaserScan,\n            '/scan',\n            self.scan_callback,\n            10\n        )\n        self.subscription  # Prevent unused variable warning\n        \n    def scan_callback(self, msg):\n        # Check if there are obstacles within 1 meter\n        safe_distance = 1.0\n        obstacles_detected = False\n        \n        for i, range_val in enumerate(msg.ranges):\n            if not math.isnan(range_val) and range_val < safe_distance:\n                angle = msg.angle_min + i * msg.angle_increment\n                self.get_logger().warn(\n                    f'Obstacle detected at {range_val:.2f}m, angle {math.degrees(angle):.1f}\xb0'\n                )\n                obstacles_detected = True\n        \n        if not obstacles_detected:\n            self.get_logger().info('Path clear')\n\ndef main():\n    rclpy.init()\n    node = ObstacleDetector()\n    \n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsx)(n.h3,{id:"creating-a-service",children:"Creating a Service"}),"\n",(0,r.jsx)(n.p,{children:"A service for simple robot commands:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# robot_service.py\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.executors import MultiThreadedExecutor\nfrom example_interfaces.srv import SetBool\n\nclass RobotService(Node):\n    def __init__(self):\n        super().__init__('robot_service')\n        \n        # Create service\n        self.srv = self.create_service(\n            SetBool, \n            'robot_enable', \n            self.enable_callback\n        )\n        self.enabled = False\n        \n    def enable_callback(self, request, response):\n        self.enabled = request.data\n        if self.enabled:\n            self.get_logger().info('Robot enabled')\n        else:\n            self.get_logger().info('Robot disabled')\n            \n        response.success = True\n        response.message = f'Robot {\"enabled\" if self.enabled else \"disabled\"}'\n        return response\n\ndef main():\n    rclpy.init()\n    node = RobotService()\n    \n    # Use multithreaded executor since services run on separate threads\n    executor = MultiThreadedExecutor()\n    executor.add_node(node)\n    \n    try:\n        executor.spin()\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsx)(n.h3,{id:"communication-pattern-selection",children:"Communication Pattern Selection"}),"\n",(0,r.jsx)(n.p,{children:"Choose the appropriate communication pattern based on your needs:"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use Topics for"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Sensor data streams"}),"\n",(0,r.jsx)(n.li,{children:"Continuous state updates"}),"\n",(0,r.jsx)(n.li,{children:"Broadcasting information to multiple consumers"}),"\n",(0,r.jsx)(n.li,{children:"When real-time performance is critical"}),"\n",(0,r.jsx)(n.li,{children:"When the publisher doesn't need to know about subscribers"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use Services for"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Discrete actions with clear outcomes"}),"\n",(0,r.jsx)(n.li,{children:"Configuration changes requiring confirmation"}),"\n",(0,r.jsx)(n.li,{children:"Computations that must complete successfully"}),"\n",(0,r.jsx)(n.li,{children:"When synchronous response is needed"}),"\n",(0,r.jsx)(n.li,{children:"When there's a clear one-to-one relationship between client and server"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use Actions for"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Long-running operations (navigation, manipulation)"}),"\n",(0,r.jsx)(n.li,{children:"When you need feedback during execution"}),"\n",(0,r.jsx)(n.li,{children:"When operations can be canceled"}),"\n",(0,r.jsx)(n.li,{children:"For goal-oriented behaviors"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"hands-on-exercise",children:"Hands-on Exercise"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Design Exercise"}),": Design a simple robot system (e.g., a mobile robot that navigates to goal positions) and specify the nodes, topics, and services required. For each communication connection, justify why you chose the pattern you did."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Implementation Exercise"}),": Build a ROS 2 node that publishes messages to a topic, and another node that subscribes to that topic and performs an action based on the received data."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Analysis Exercise"}),": For a robot performing a sequence of tasks (e.g., navigate to location A, pick up object, navigate to location B, place object), identify which steps should use topics, services, and actions, and explain your reasoning."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Nodes encapsulate computational functionality in ROS 2"}),"\n",(0,r.jsx)(n.li,{children:"Topics provide asynchronous, decoupled communication"}),"\n",(0,r.jsx)(n.li,{children:"Services provide synchronous request-response communication"}),"\n",(0,r.jsx)(n.li,{children:"Quality of Service settings allow fine-tuning of communication behavior"}),"\n",(0,r.jsx)(n.li,{children:"Appropriate choice of communication pattern is critical for system performance"}),"\n",(0,r.jsx)(n.li,{children:"Topics are for continuous data streams, services for discrete actions"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:'"ROS Robotics Projects" by Anis Koubaa'}),"\n",(0,r.jsx)(n.li,{children:"ROS 2 Design documentation on Quality of Service policies"}),"\n",(0,r.jsx)(n.li,{children:'"Programming Robots with ROS" by Quigley et al.'}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,r.jsx)(n.p,{children:"Continue to Chapter 3: Python and rclpy to learn how to implement ROS 2 nodes using Python."})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>a});var i=s(6540);const r={},o=i.createContext(r);function t(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);