"use strict";(globalThis.webpackChunkphysical_ai_robotics_book=globalThis.webpackChunkphysical_ai_robotics_book||[]).push([[2025],{1504:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module-05-humanoid-control/part-01-locomotion/humanoid-kinematics","title":"Humanoid Kinematics","description":"This chapter explores the kinematic principles underlying humanoid robots, focusing on the mathematical models that describe how these complex robots move and interact with their environment. Humanoid kinematics involve understanding the relationships between joint angles and the positions and orientations of various body parts.","source":"@site/docs/module-05-humanoid-control/part-01-locomotion/01-humanoid-kinematics.md","sourceDirName":"module-05-humanoid-control/part-01-locomotion","slug":"/module-05-humanoid-control/part-01-locomotion/humanoid-kinematics","permalink":"/Physical_AI_And_Humanoid_Robotics_Book/docs/module-05-humanoid-control/part-01-locomotion/humanoid-kinematics","draft":false,"unlisted":false,"editUrl":"https://github.com/Tayyaba-Akbar956/Physical_AI_And_Humanoid_Robotics_Book/tree/main/docs/module-05-humanoid-control/part-01-locomotion/01-humanoid-kinematics.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"title":"Humanoid Kinematics"},"sidebar":"tutorialSidebar","previous":{"title":"Isaac ROS Integration","permalink":"/Physical_AI_And_Humanoid_Robotics_Book/docs/module-04-isaac-nvidia/part-02-advanced-intelligence/sim-integration"},"next":{"title":"Bipedal Locomotion","permalink":"/Physical_AI_And_Humanoid_Robotics_Book/docs/module-05-humanoid-control/part-01-locomotion/bipedal-locomotion"}}');var o=i(4848),a=i(8453);const s={sidebar_position:1,title:"Humanoid Kinematics"},r="Humanoid Kinematics",l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction: The Complexity of Humanoid Motion",id:"introduction-the-complexity-of-humanoid-motion",level:2},{value:"Key Challenges in Humanoid Kinematics",id:"key-challenges-in-humanoid-kinematics",level:3},{value:"Humanoid vs. Human Motion",id:"humanoid-vs-human-motion",level:3},{value:"Core Concepts",id:"core-concepts",level:2},{value:"Kinematic Chains",id:"kinematic-chains",level:3},{value:"Coordinate Systems",id:"coordinate-systems",level:3},{value:"Degrees of Freedom Analysis",id:"degrees-of-freedom-analysis",level:3},{value:"Mathematical Framework",id:"mathematical-framework",level:2},{value:"Forward Kinematics",id:"forward-kinematics",level:3},{value:"Inverse Kinematics",id:"inverse-kinematics",level:3},{value:"Balance and Locomotion",id:"balance-and-locomotion",level:3},{value:"Practical Implementation",id:"practical-implementation",level:2},{value:"Denavit-Hartenberg Parameters for Humanoid Robots",id:"denavit-hartenberg-parameters-for-humanoid-robots",level:3},{value:"Kinematic Solutions for Humanoid Locomotion",id:"kinematic-solutions-for-humanoid-locomotion",level:3},{value:"Balance Control Implementation",id:"balance-control-implementation",level:3},{value:"Walking Pattern Generation",id:"walking-pattern-generation",level:3},{value:"Advanced Topics",id:"advanced-topics",level:2},{value:"Whole-Body Kinematics",id:"whole-body-kinematics",level:3},{value:"Kinematic Redundancy",id:"kinematic-redundancy",level:3},{value:"Troubleshooting Common Issues",id:"troubleshooting-common-issues",level:2},{value:"Singularity Problems",id:"singularity-problems",level:3},{value:"Balance Instability",id:"balance-instability",level:3},{value:"Inverse Kinematics Convergence",id:"inverse-kinematics-convergence",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Model Accuracy",id:"model-accuracy",level:3},{value:"Computational Efficiency",id:"computational-efficiency",level:3},{value:"Safety",id:"safety",level:3},{value:"Hands-on Exercise",id:"hands-on-exercise",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2},{value:"Further Reading",id:"further-reading",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"humanoid-kinematics",children:"Humanoid Kinematics"})}),"\n",(0,o.jsx)(e.p,{children:"This chapter explores the kinematic principles underlying humanoid robots, focusing on the mathematical models that describe how these complex robots move and interact with their environment. Humanoid kinematics involve understanding the relationships between joint angles and the positions and orientations of various body parts."}),"\n",(0,o.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Understand the kinematic structure of humanoid robots"}),"\n",(0,o.jsx)(e.li,{children:"Apply forward and inverse kinematics to humanoid systems"}),"\n",(0,o.jsx)(e.li,{children:"Identify the challenges specific to humanoid locomotion"}),"\n",(0,o.jsx)(e.li,{children:"Implement kinematic solutions for humanoid robots"}),"\n",(0,o.jsx)(e.li,{children:"Analyze the constraints and degrees of freedom in humanoid systems"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"introduction-the-complexity-of-humanoid-motion",children:"Introduction: The Complexity of Humanoid Motion"}),"\n",(0,o.jsx)(e.p,{children:"Humanoid robots present unique kinematic challenges compared to simpler robotic systems. With multiple degrees of freedom (DOF) distributed across legs, arms, torso, and head, these robots must solve complex kinematic problems for stable locomotion and manipulation. Unlike wheeled robots or robotic arms, humanoid systems must maintain balance while moving through 3D environments."}),"\n",(0,o.jsx)(e.p,{children:"The human body has approximately 200+ joints, but humanoid robots typically have 20-50 actuated joints, carefully selected to enable essential movements for navigation and interaction. The kinematic structure of a humanoid robot affects its ability to walk, run, climb, manipulate objects, and maintain stability."}),"\n",(0,o.jsx)(e.h3,{id:"key-challenges-in-humanoid-kinematics",children:"Key Challenges in Humanoid Kinematics"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Balance Maintenance"}),": Humanoid robots must maintain their center of mass (CoM) within their support polygon to avoid falling"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Multi-Limbed Coordination"}),": Arms and legs must be coordinated to maintain balance while performing tasks"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Obstacle Avoidance"}),": Multiple limbs must be coordinated to avoid self-collision and environmental obstacles"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Dynamic Stability"}),": Maintaining balance during movement, not just in static poses"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"humanoid-vs-human-motion",children:"Humanoid vs. Human Motion"}),"\n",(0,o.jsx)(e.p,{children:"While humanoid robots aim to replicate human-like movement, there are fundamental differences:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Degrees of Freedom"}),": Humans have redundant DOF in many joints, allowing for multiple solutions to the same task"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Compliance"}),": Human joints have built-in compliance that helps with shock absorption and safety"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Adaptability"}),": Human motion can adapt in real-time to unexpected perturbations"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Energy Efficiency"}),": Human biomechanics have evolved for energy-efficient locomotion"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,o.jsx)(e.h3,{id:"kinematic-chains",children:"Kinematic Chains"}),"\n",(0,o.jsx)(e.p,{children:"A humanoid robot consists of multiple kinematic chains that must work together:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Leg Chains"}),": From hip to foot, enabling locomotion and balance"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Arm Chains"}),": From shoulder to hand, for manipulation tasks"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Spine Chain"}),": Torso movement and upper body orientation"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Head Chain"}),": Neck movement for vision and interaction"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"coordinate-systems",children:"Coordinate Systems"}),"\n",(0,o.jsx)(e.p,{children:"Humanoid kinematics typically use several coordinate systems:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"World Frame"}),": Fixed reference frame for the environment"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Base Frame"}),": Usually located at the robot's pelvis or between the feet"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Link Frames"}),": Attached to each rigid body segment"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"End-Effector Frames"}),": Located at hands and feet"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Center of Mass Frame"}),": For balance control"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"degrees-of-freedom-analysis",children:"Degrees of Freedom Analysis"}),"\n",(0,o.jsx)(e.p,{children:"A typical humanoid robot has:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"6 DOF in each leg (hip: 3 DOF, knee: 1 DOF, ankle: 2 DOF)"}),"\n",(0,o.jsx)(e.li,{children:"7 DOF in each arm (shoulder: 3 DOF, elbow: 1 DOF, wrist: 3 DOF)"}),"\n",(0,o.jsx)(e.li,{children:"3-6 DOF in the torso/spine"}),"\n",(0,o.jsx)(e.li,{children:"2-3 DOF in the neck/head"}),"\n",(0,o.jsx)(e.li,{children:"Total: 28+ DOF for a basic humanoid"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"mathematical-framework",children:"Mathematical Framework"}),"\n",(0,o.jsx)(e.h3,{id:"forward-kinematics",children:"Forward Kinematics"}),"\n",(0,o.jsx)(e.p,{children:"Forward kinematics determines the position and orientation of each link given the joint angles. For humanoid robots, this involves complex transformations through multiple kinematic chains."}),"\n",(0,o.jsx)(e.p,{children:"For a humanoid leg, the transformation from hip to foot can be expressed as:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"T_foot = T_hip * A1(\u03b81) * A2(\u03b82) * ... * A6(\u03b86)\n"})}),"\n",(0,o.jsxs)(e.p,{children:["Where ",(0,o.jsx)(e.code,{children:"A_i(\u03b8_i)"})," represents the transformation matrix for joint i with angle \u03b8_i."]}),"\n",(0,o.jsx)(e.h3,{id:"inverse-kinematics",children:"Inverse Kinematics"}),"\n",(0,o.jsx)(e.p,{children:"Inverse kinematics determines the required joint angles to achieve a desired end-effector position and orientation. For humanoid robots, this is often an ill-posed problem with multiple solutions, requiring optimization criteria such as:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Minimizing joint movement from current configuration"}),"\n",(0,o.jsx)(e.li,{children:"Maintaining joint limits"}),"\n",(0,o.jsx)(e.li,{children:"Avoiding singularities"}),"\n",(0,o.jsx)(e.li,{children:"Optimizing for balance"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"balance-and-locomotion",children:"Balance and Locomotion"}),"\n",(0,o.jsx)(e.p,{children:"Humanoid locomotion requires special attention to:"}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Zero-Moment Point (ZMP)"}),":"]}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"A point where the net moment of ground reaction forces equals zero"}),"\n",(0,o.jsx)(e.li,{children:"Critical for stable walking"}),"\n",(0,o.jsx)(e.li,{children:"Must remain within the support polygon (foot area)"}),"\n"]}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Capture Point"}),":"]}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"A point where the robot can step to stop its motion"}),"\n",(0,o.jsx)(e.li,{children:"Important for recovery from disturbances"}),"\n"]}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Center of Mass (CoM)"}),":"]}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Must be controlled to remain within the support polygon"}),"\n",(0,o.jsx)(e.li,{children:"Used in balance control strategies"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"practical-implementation",children:"Practical Implementation"}),"\n",(0,o.jsx)(e.h3,{id:"denavit-hartenberg-parameters-for-humanoid-robots",children:"Denavit-Hartenberg Parameters for Humanoid Robots"}),"\n",(0,o.jsx)(e.p,{children:"While the Denavit-Hartenberg (DH) convention is commonly used for robot arms, humanoid robots often use alternative representations due to their complex structure. However, DH parameters can still be applied to individual limbs:"}),"\n",(0,o.jsx)(e.p,{children:"For a humanoid leg with 6 DOF:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Joint 1 (Hip Yaw): \u03b10, a0, d1, \u03b81"}),"\n",(0,o.jsx)(e.li,{children:"Joint 2 (Hip Roll): \u03b11, a1, d2, \u03b82"}),"\n",(0,o.jsx)(e.li,{children:"Joint 3 (Hip Pitch): \u03b12, a2, d3, \u03b83"}),"\n",(0,o.jsx)(e.li,{children:"Joint 4 (Knee): \u03b13, a3, d4, \u03b84"}),"\n",(0,o.jsx)(e.li,{children:"Joint 5 (Ankle Pitch): \u03b14, a4, d5, \u03b85"}),"\n",(0,o.jsx)(e.li,{children:"Joint 6 (Ankle Roll): \u03b15, a5, d6, \u03b86"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"kinematic-solutions-for-humanoid-locomotion",children:"Kinematic Solutions for Humanoid Locomotion"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"import numpy as np\nfrom scipy.spatial.transform import Rotation as R\n\nclass HumanoidKinematics:\n    def __init__(self, leg_params):\n        \"\"\"\n        Initialize kinematic parameters for a humanoid robot\n        \n        Args:\n            leg_params: Dictionary containing link lengths and joint limits\n        \"\"\"\n        self.leg_params = leg_params\n        self.hip_offset = leg_params.get('hip_offset', [0.0, 0.1, 0.0])  # Lateral hip offset\n        \n    def homogeneous_transform(self, theta, d, a, alpha):\n        \"\"\"Calculate homogeneous transformation matrix for DH parameters\"\"\"\n        st, ct = np.sin(theta), np.cos(theta)\n        sa, ca = np.sin(alpha), np.cos(alpha)\n        \n        T = np.array([\n            [ct, -st*ca, st*sa, a*ct],\n            [st, ct*ca, -ct*sa, a*st],\n            [0, sa, ca, d],\n            [0, 0, 0, 1]\n        ])\n        return T\n    \n    def leg_forward_kinematics(self, joint_angles):\n        \"\"\"\n        Calculate forward kinematics for a single leg\n        \n        Args:\n            joint_angles: List of 6 joint angles [hip_yaw, hip_roll, hip_pitch, knee, ankle_pitch, ankle_roll]\n        \n        Returns:\n            Position [x, y, z] and orientation (as quaternion) of the foot\n        \"\"\"\n        # Simplified model - in practice, each joint would have its own DH parameters\n        # This is a conceptual implementation\n        \n        # Base transformation (hip position)\n        T_base = np.eye(4)\n        T_base[0:3, 3] = [0, self.leg_params['hip_y_offset'], self.leg_params['hip_z_offset']]\n        \n        # Calculate transformations for each joint\n        T_total = T_base\n        for i, angle in enumerate(joint_angles):\n            # This is a simplified representation\n            # In practice, each joint would modify T_total differently\n            joint_transform = self.get_joint_transform(i, angle)\n            T_total = T_total @ joint_transform\n        \n        # Extract position and orientation\n        position = T_total[0:3, 3]\n        rotation_matrix = T_total[0:3, 0:3]\n        quaternion = R.from_matrix(rotation_matrix).as_quat()\n        \n        return position, quaternion\n    \n    def get_joint_transform(self, joint_idx, angle):\n        \"\"\"Get transformation matrix for a specific joint\"\"\"\n        # This is a simplified model - a complete implementation would use actual DH parameters\n        T = np.eye(4)\n        \n        if joint_idx == 0:  # Hip Yaw\n            T[0:3, 0:3] = R.from_euler('z', angle).as_matrix()\n        elif joint_idx == 1:  # Hip Roll\n            T[0:3, 0:3] = R.from_euler('x', angle).as_matrix()\n        elif joint_idx == 2:  # Hip Pitch\n            T[0:3, 0:3] = R.from_euler('y', angle).as_matrix()\n        elif joint_idx == 3:  # Knee\n            T[0:3, 0:3] = R.from_euler('y', angle).as_matrix()\n        elif joint_idx == 4:  # Ankle Pitch\n            T[0:3, 0:3] = R.from_euler('y', angle).as_matrix()\n        elif joint_idx == 5:  # Ankle Roll\n            T[0:3, 0:3] = R.from_euler('x', angle).as_matrix()\n        \n        return T\n    \n    def calculate_inverse_kinematics(self, target_position, target_orientation, chain_type='leg'):\n        \"\"\"\n        Calculate inverse kinematics for a kinematic chain\n        \n        Args:\n            target_position: Desired [x, y, z] position of end effector\n            target_orientation: Desired orientation (quaternion)\n            chain_type: Type of chain ('leg', 'arm', etc.)\n        \n        Returns:\n            Joint angles that achieve the target pose (or closest approximation)\n        \"\"\"\n        if chain_type == 'leg':\n            # Simplified inverse kinematics for leg\n            # In reality, this would be much more complex and possibly iterative\n            return self.calculate_leg_ik(target_position, target_orientation)\n        elif chain_type == 'arm':\n            # Simplified inverse kinematics for arm\n            return self.calculate_arm_ik(target_position, target_orientation)\n        else:\n            raise ValueError(f\"Unknown chain type: {chain_type}\")\n    \n    def calculate_leg_ik(self, target_pos, target_quat):\n        \"\"\"Simplified inverse kinematics for leg (conceptual implementation)\"\"\"\n        # This is a simplified implementation\n        # In practice, humanoid leg IK involves complex geometric and numerical solutions\n        \n        # Calculate hip-to-foot vector\n        hip_to_foot = target_pos - np.array([0, self.leg_params['hip_y_offset'], self.leg_params['hip_z_offset']])\n        \n        # Simplified solution: ignore hip rotation for now\n        # In reality, hip yaw, roll, and pitch would be calculated based on foot position\n        hip_yaw = np.arctan2(hip_to_foot[1], hip_to_foot[0])\n        \n        # Calculate knee angle based on leg length\n        xy_dist = np.sqrt(hip_to_foot[0]**2 + hip_to_foot[1]**2)\n        z_dist = hip_to_foot[2]\n        leg_length = np.sqrt(xy_dist**2 + z_dist**2)\n        \n        # Assuming 2-link leg model (thigh and shank)\n        thigh_length = self.leg_params['thigh_length']\n        shank_length = self.leg_params['shank_length']\n        \n        # Law of cosines to calculate knee angle\n        cos_knee = (thigh_length**2 + shank_length**2 - leg_length**2) / (2 * thigh_length * shank_length)\n        knee_angle = np.pi - np.arccos(np.clip(cos_knee, -1, 1))\n        \n        # Calculate hip pitch to reach target\n        # This is simplified and in reality involves more complex calculations\n        hip_pitch = np.arctan2(z_dist, xy_dist)  # This is a very simplified approximation\n        \n        # Ankle angles to achieve desired foot orientation\n        # Would need to consider current leg configuration\n        ankle_pitch = 0.0\n        ankle_roll = 0.0\n        \n        joint_angles = [\n            hip_yaw,      # Hip Yaw\n            0.0,          # Hip Roll (simplified)\n            hip_pitch,    # Hip Pitch\n            knee_angle,   # Knee\n            ankle_pitch,  # Ankle Pitch\n            ankle_roll    # Ankle Roll\n        ]\n        \n        return np.array(joint_angles)\n\n# Example usage\nif __name__ == \"__main__\":\n    # Define leg parameters\n    leg_params = {\n        'hip_y_offset': 0.1,      # Lateral hip offset\n        'hip_z_offset': 0.9,      # Hip height above ankle\n        'thigh_length': 0.45,     # Length from hip to knee\n        'shank_length': 0.45,     # Length from knee to ankle\n        'foot_length': 0.25       # Length of foot\n    }\n    \n    # Initialize kinematics\n    kin = HumanoidKinematics(leg_params)\n    \n    # Calculate forward kinematics\n    joint_angles = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]  # Initial position\n    pos, quat = kin.leg_forward_kinematics(joint_angles)\n    print(f\"Foot position: {pos}, orientation: {quat}\")\n    \n    # Calculate inverse kinematics\n    target_pos = [0.0, 0.0, -0.8]  # Target foot position (x=0, y=0, z=-0.8m)\n    target_quat = [0, 0, 0, 1]     # Identity orientation\n    ik_angles = kin.calculate_inverse_kinematics(target_pos, target_quat, 'leg')\n    print(f\"IK joint angles: {ik_angles}\")\n"})}),"\n",(0,o.jsx)(e.h3,{id:"balance-control-implementation",children:"Balance Control Implementation"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'class BalanceController:\n    def __init__(self, robot_params):\n        """\n        Initialize balance controller for humanoid robot\n        \n        Args:\n            robot_params: Dictionary containing robot physical parameters\n        """\n        self.mass = robot_params.get(\'total_mass\', 50.0)  # kg\n        self.gravity = 9.81  # m/s^2\n        self.support_polygon = []  # vertices of support polygon (foot area)\n        self.com_threshold = robot_params.get(\'com_threshold\', 0.05)  # 5cm threshold\n        \n    def calculate_support_polygon(self, left_foot_pos, right_foot_pos):\n        """Calculate support polygon based on foot positions"""\n        # Simplified support polygon as a rectangle between feet\n        # In practice, this would be based on actual foot geometry\n        \n        # Calculate average foot position for double support\n        avg_x = (left_foot_pos[0] + right_foot_pos[0]) / 2.0\n        avg_y = (left_foot_pos[1] + right_foot_pos[1]) / 2.0\n        \n        # Calculate polygon vertices (simplified as a box)\n        width = abs(left_foot_pos[1] - right_foot_pos[1])  # distance between feet\n        length = 0.3  # approximate foot length\n        \n        vertices = [\n            [avg_x - length/2, avg_y - width/2, 0],\n            [avg_x + length/2, avg_y - width/2, 0],\n            [avg_x + length/2, avg_y + width/2, 0],\n            [avg_x - length/2, avg_y + width/2, 0]\n        ]\n        \n        return vertices\n    \n    def is_stable(self, com_position):\n        """Check if the robot is in a stable state"""\n        # Calculate projection of CoM onto ground plane\n        com_proj = [com_position[0], com_position[1], 0]\n        \n        # Check if CoM projection is within support polygon\n        # Using a simplified point-in-polygon test\n        return self.point_in_polygon(com_proj, self.support_polygon)\n    \n    def point_in_polygon(self, point, polygon):\n        """Check if a point is inside a polygon (simplified implementation)"""\n        # This is a conceptual implementation\n        # Real application would use proper geometric algorithms\n        \n        x, y = point[0], point[1]\n        \n        # Simplified: check if point is within bounding box of polygon\n        xs = [v[0] for v in polygon]\n        ys = [v[1] for v in polygon]\n        \n        min_x, max_x = min(xs), max(xs)\n        min_y, max_y = min(ys), max(ys)\n        \n        return min_x <= x <= max_x and min_y <= y <= max_y\n    \n    def compute_zmp(self, com_position, com_velocity, com_acceleration):\n        """Calculate Zero Moment Point from CoM information"""\n        # ZMP = [CoM_x - (g/h) * CoM_accel_x, CoM_y - (g/h) * CoM_accel_y]\n        # where h is the height of the CoM above ground\n        \n        h = com_position[2]  # height of CoM above ground\n        if h <= 0:\n            h = 0.001  # prevent division by zero\n        \n        zmp_x = com_position[0] - (self.gravity / h) * com_acceleration[0]\n        zmp_y = com_position[1] - (self.gravity / h) * com_acceleration[1]\n        \n        return [zmp_x, zmp_y, 0]\n    \n    def adjust_posture_for_balance(self, current_com, desired_com):\n        """Adjust joint angles to maintain balance"""\n        # This would involve complex control algorithms\n        # such as PID controllers, model predictive control, etc.\n        \n        # Simplified approach: adjust based on CoM error\n        com_error = np.array(desired_com) - np.array(current_com)\n        \n        # Return a compensation value for joints\n        # In practice, this would be translated to joint angle adjustments\n        compensation = 0.5 * com_error  # proportional control (simplified)\n        \n        return compensation\n'})}),"\n",(0,o.jsx)(e.h3,{id:"walking-pattern-generation",children:"Walking Pattern Generation"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"class WalkingPatternGenerator:\n    def __init__(self, step_params):\n        \"\"\"\n        Initialize walking pattern generator\n        \n        Args:\n            step_params: Dictionary containing walking parameters\n        \"\"\"\n        self.step_length = step_params.get('step_length', 0.3)  # m\n        self.step_width = step_params.get('step_width', 0.2)   # m\n        self.step_height = step_params.get('step_height', 0.05) # m\n        self.step_duration = step_params.get('step_duration', 1.0)  # s\n        self.zmp_margin = step_params.get('zmp_margin', 0.02)  # safety margin\n        \n    def generate_walking_pattern(self, num_steps, start_pos=[0, 0, 0]):\n        \"\"\"Generate a walking pattern for the specified number of steps\"\"\"\n        # This is a conceptual implementation of a walking pattern generator\n        # A complete implementation would use the inverted pendulum model or similar\n        \n        pattern = []\n        \n        # Initial position\n        current_pos = list(start_pos)\n        \n        for i in range(num_steps):\n            # Determine if this is a right or left step\n            is_right_step = (i % 2 == 1)\n            \n            # Calculate foot position for this step\n            if is_right_step:\n                foot_pos = [\n                    current_pos[0] + self.step_length,\n                    current_pos[1] - self.step_width/2,  # Right foot to the right\n                    current_pos[2]\n                ]\n            else:\n                foot_pos = [\n                    current_pos[0] + self.step_length,\n                    current_pos[1] + self.step_width/2,  # Left foot to the left\n                    current_pos[2]\n                ]\n            \n            # Generate step trajectory (simplified as a 3-point arc)\n            step_trajectory = self.generate_step_trajectory(\n                current_pos, foot_pos, self.step_height, self.step_duration\n            )\n            \n            # Update current position for next step\n            current_pos[0] = foot_pos[0]  # Move forward\n            current_pos[1] = 0  # Return to center line\n            \n            pattern.append({\n                'step_number': i + 1,\n                'foot_position': foot_pos,\n                'is_right_foot': is_right_step,\n                'trajectory': step_trajectory\n            })\n        \n        return pattern\n    \n    def generate_step_trajectory(self, start_pos, end_pos, step_height, duration):\n        \"\"\"Generate a trajectory for a single step\"\"\"\n        # Create a 3D trajectory for the foot movement\n        # This is simplified to a parabolic arc in the z-direction\n        # and linear movement in x and y directions\n        \n        trajectory = []\n        num_points = 20  # number of points in the trajectory\n        \n        for i in range(num_points):\n            t = i / (num_points - 1)  # normalized time (0 to 1)\n            \n            # Linear interpolation for x and y\n            x = start_pos[0] + t * (end_pos[0] - start_pos[0])\n            y = start_pos[1] + t * (end_pos[1] - start_pos[1])\n            \n            # Parabolic interpolation for z (to create step motion)\n            # Peak at t = 0.5\n            z = start_pos[2] + 4 * step_height * t * (1 - t)\n            \n            trajectory.append([x, y, z])\n        \n        return trajectory\n"})}),"\n",(0,o.jsx)(e.h2,{id:"advanced-topics",children:"Advanced Topics"}),"\n",(0,o.jsx)(e.h3,{id:"whole-body-kinematics",children:"Whole-Body Kinematics"}),"\n",(0,o.jsx)(e.p,{children:"Humanoid robots often use whole-body kinematic controllers that coordinate all joints simultaneously to achieve multiple tasks:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Maintaining balance"}),"\n",(0,o.jsx)(e.li,{children:"Following a walking pattern"}),"\n",(0,o.jsx)(e.li,{children:"Controlling arm movements"}),"\n",(0,o.jsx)(e.li,{children:"Keeping head oriented toward targets"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"This is typically formulated as an optimization problem that minimizes a cost function while satisfying constraints."}),"\n",(0,o.jsx)(e.h3,{id:"kinematic-redundancy",children:"Kinematic Redundancy"}),"\n",(0,o.jsx)(e.p,{children:"Humanoid robots have redundant DOF that can be used for secondary objectives like:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Avoiding joint limits"}),"\n",(0,o.jsx)(e.li,{children:"Maintaining comfortable postures"}),"\n",(0,o.jsx)(e.li,{children:"Avoiding obstacles"}),"\n",(0,o.jsx)(e.li,{children:"Optimizing energy consumption"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"troubleshooting-common-issues",children:"Troubleshooting Common Issues"}),"\n",(0,o.jsx)(e.h3,{id:"singularity-problems",children:"Singularity Problems"}),"\n",(0,o.jsx)(e.p,{children:"Humanoid robots can experience kinematic singularities where the Jacobian matrix becomes rank-deficient. To address this:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Regularly check for singular configurations"}),"\n",(0,o.jsx)(e.li,{children:"Use damped least squares methods"}),"\n",(0,o.jsx)(e.li,{children:"Implement joint limit avoidance"}),"\n",(0,o.jsx)(e.li,{children:"Plan paths that avoid singular regions"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"balance-instability",children:"Balance Instability"}),"\n",(0,o.jsx)(e.p,{children:"If your humanoid robot experiences balance issues:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Verify CoM calculation accuracy"}),"\n",(0,o.jsx)(e.li,{children:"Check support polygon computation"}),"\n",(0,o.jsx)(e.li,{children:"Adjust control gains appropriately"}),"\n",(0,o.jsx)(e.li,{children:"Verify sensor calibration (IMU, force/torque sensors)"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"inverse-kinematics-convergence",children:"Inverse Kinematics Convergence"}),"\n",(0,o.jsx)(e.p,{children:"If IK solutions fail to converge:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Check for joint limit violations"}),"\n",(0,o.jsx)(e.li,{children:"Verify that target poses are reachable"}),"\n",(0,o.jsx)(e.li,{children:"Use better initial guesses for iterative solvers"}),"\n",(0,o.jsx)(e.li,{children:"Consider using multiple different IK algorithms"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,o.jsx)(e.h3,{id:"model-accuracy",children:"Model Accuracy"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Use accurate physical models of your robot"}),"\n",(0,o.jsx)(e.li,{children:"Regularly update kinematic parameters based on measurements"}),"\n",(0,o.jsx)(e.li,{children:"Account for actual joint limits and velocity limits"}),"\n",(0,o.jsx)(e.li,{children:"Include compliance effects in high-precision applications"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"computational-efficiency",children:"Computational Efficiency"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Precompute Jacobians when possible"}),"\n",(0,o.jsx)(e.li,{children:"Use efficient numerical methods"}),"\n",(0,o.jsx)(e.li,{children:"Consider hybrid analytical/numerical approaches"}),"\n",(0,o.jsx)(e.li,{children:"Implement caching for repeated calculations"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"safety",children:"Safety"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Always check for collisions during motion planning"}),"\n",(0,o.jsx)(e.li,{children:"Verify balance before executing motions"}),"\n",(0,o.jsx)(e.li,{children:"Implement emergency stop procedures"}),"\n",(0,o.jsx)(e.li,{children:"Use conservative control parameters initially"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"hands-on-exercise",children:"Hands-on Exercise"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Kinematic Analysis"}),": Analyze the kinematic chain of a humanoid robot design. Determine the total degrees of freedom and identify which joints contribute to balance vs. manipulation."]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Forward Kinematics Implementation"}),": Implement forward kinematics for a simplified 6-DOF leg model using the DH parameters approach. Verify your implementation by comparing end-effector positions for known joint angles."]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Balance Simulation"}),": Create a simulation of a humanoid robot standing on one foot. Calculate the center of mass position and verify it remains within the support polygon of the supporting foot."]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Walking Pattern Generation"}),": Implement a simple walking pattern generator for a humanoid robot. Generate step positions for a 10-step forward walk and visualize the resulting path."]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Inverse Kinematics Challenge"}),": Implement an inverse kinematics solution for positioning a humanoid robot's foot at a specific location. Test with various target positions to verify reachability."]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Humanoid kinematics involve complex multi-chain coordination"}),"\n",(0,o.jsx)(e.li,{children:"Balance is a primary concern in humanoid robotics"}),"\n",(0,o.jsx)(e.li,{children:"Forward and inverse kinematics must consider all links simultaneously"}),"\n",(0,o.jsx)(e.li,{children:"Efficient algorithms are essential for real-time control"}),"\n",(0,o.jsx)(e.li,{children:"Safety and stability constraints are critical in motion planning"}),"\n",(0,o.jsx)(e.li,{children:"Modeling accuracy directly impacts performance"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:'"Introduction to Humanoid Robotics" by Shumskaya and Kajita'}),"\n",(0,o.jsx)(e.li,{children:'"Humanoid Robotics" by Herr and Bellman'}),"\n",(0,o.jsx)(e.li,{children:'"Kinematic Modeling, Reduction and Planning of Humanoid Robots" - Technical papers'}),"\n",(0,o.jsx)(e.li,{children:"ROS MoveIt! documentation for motion planning"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,o.jsx)(e.p,{children:"Continue to Chapter 2: Bipedal Locomotion to explore the dynamics and control strategies for humanoid walking."})]})}function h(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>s,x:()=>r});var t=i(6540);const o={},a=t.createContext(o);function s(n){const e=t.useContext(a);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:s(n.components),t.createElement(a.Provider,{value:e},n.children)}}}]);